<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2019 年的思考总结</title>
      <link href="/2019/12/30/nian-mo-zong-jie/"/>
      <url>/2019/12/30/nian-mo-zong-jie/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=411214279&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>首先依照国际惯例来个自我介绍，我叫 linfeng，参加工作两年多。来掘金一年多了，刚开始的时候觉得这平台不错，文章质量过硬，而且人气很高；经常在搜索引擎搜素不到的知识点，在掘金能够找到对应的博客。<br>再来讲讲我的工作，作为一个前端，我的技术栈是 vue、css3 、canvas、gis、react-native 以及会点 react。</p><h1 id="2019-年成长之路"><a href="#2019-年成长之路" class="headerlink" title="2019 年成长之路"></a>2019 年成长之路</h1><blockquote><p>2019 年对于整个互联网行业来说是十分坎坷的一年，从年头开始整个行业就被各种的倒闭、欠薪以及裁员等负面消息所笼盖，被称之为互联网寒冬。</p></blockquote><p>作为一名小前端，为了不被寒冬冻僵，2019 年我在努力地为自己穿上防寒外套。做了下面几个方面进行了学习和研究：</p><h1 id="React-Native"><a href="#React-Native" class="headerlink" title="React-Native()"></a>React-Native()</h1><p>从 2019 年 9 月份开始到现在,断断续续做了几个月。我们做的是一款环保类型的内部使用 APP,主要检测业务空气、水环境等等业务,说到这里不得不说下 RN 的优劣:</p><h2 id="RN-的优势"><a href="#RN-的优势" class="headerlink" title="RN 的优势"></a>RN 的优势</h2><ul><li><p>调试方便<br>ipa 安装好之后，就不需要频繁编译了，只需要 reload 一下，把 js 代码从云服务器下载下来就可以呈现改变代码后的效果。而且 RN 支持 hotReload，在调试界面的时候非常方便，修改代码之后保存，界面就自动跟着变化，这一点在调试的时候实在很爽，不过有时候有点慢，需要 reload。chrome 在线调试也挺不错，可以打断点，看日志。虽然没有 xcode 或者 Android Studio 那么浑然一体，但是作为脚本语言的调试工具，也是很厉害了。</p></li><li><p>css-layout 布局<br>这对于前端程序员来说，降低了不少学习成本，也大大减少了代码量。但是对于 iOS 或者安卓开发者来说，刚开始接触的时候，得接受一些思想上的转变。</p></li><li><p>跨平台<br>大多数代码，只需要写一套，安卓和 iOS 就都可以运行了，游戏逻辑和数据。界面上一部分有一些平台区分，毕竟是从 react 包装上来的。刚开始学 iOS 的时候，就想象着，要是有一种跨平台的开发形式就很 6 了，没想到过了几年就有了。跨平台理论上是可以减少开发成本的，减少开发人员数量，但是实际效果并不然，后面说。</p></li><li><p>热更新<br>这可能也是大多数公司选择使用 RN 的主要原因。频繁的 app 升级会让用户很烦，而且苹果的审核真是很麻烦。现在很多大型 app 都使用了 RN，毕竟繁多的业务迭代，每次都通过 APP 审核，也算是噩梦啊。</p></li></ul><h2 id="RN-的不完善"><a href="#RN-的不完善" class="headerlink" title="RN 的不完善"></a>RN 的不完善</h2><p>容我吐槽一下，不完善的地方实在太多了，和原生开发体验来比，堪称天壤之别。RN 现在的最新版本是 0.46，我们工程中用的是 0.42，毕竟还没上 1.0 呢。<br>去掉主观情感，下面列举一下部分不完善的点：</p><ul><li><p>开发体验一般。<br>虽然 js 语法很灵活，但毕竟是脚本语言，调试起来还是不方便，不好查错。我们用的表现较好的 vscode 编辑器，就这都感觉各种跳转很不方便，动不动就得全局搜索，可能是 xcode 用习惯了吧。脚本语言的编写也会慢慢习惯吧。</p></li><li><p>文档很粗略<br>官网上的文档，就只是简单介绍用法和各个控件的属性，对细节的描述很少。当你遇到难解决的问题或者踩到坑了，上面基本找不到答案。</p></li><li><p>两个平台还没有完全统一<br>很多控件都是 iOS 专属，或者安卓专属。还有同一些控件，在不同平台上表现差异很大。</p></li><li><p>控件不完善<br>这个其实挺多的，最基本的 ListView，功能缺失，坑很多。Text 不支持富文本，动画，手势，ScrollView 等等等等。不能一一列举。作为聊天软件，富文本功能必须实现啊，用于 emoji 表情和文字的混合显示。被迫自己搞了一套实现方案，现在还有点小 bug。具体实现方案参考<a href="http://blog.csdn.net/gang544043963/article/details/70245850" target="_blank" rel="noopener">http://blog.csdn.net/gang544043963/article/details/70245850</a></p></li><li><p>升级 RN 版本需要大动干戈<br>近期我们做了一次 RN 版本升级，从原来的 0.42 升到最近的 0.50。真的挺麻烦。新版把 PropTyps 从 React 中移了出来，那么之前的引用方式就得变，所有的文件挨个查。之前使用的第三方库，有和 PropTyps 相关的，都得一一更新。之前很多界面布局的时候，在 image 上放置了一些其他控件，升级后会报错，然后一一调整。</p></li><li><p>要做出优质 app 需要花费大量人力和时间去打磨<br>跨平台，其实并没有减少开发成本，原来我们安卓和 iOS 各三个人，每次迭代都是有序进行。然而换了 RN 之后，6 个人全上，做的累的啊，迭代慢，bug 多。</p></li></ul><h1 id="React-ps-平时工作不用-闲暇研究…"><a href="#React-ps-平时工作不用-闲暇研究…" class="headerlink" title="React ( ps:平时工作不用,闲暇研究… )"></a>React ( ps:平时工作不用,闲暇研究… )</h1><p>前端三大主流框架:React、Vue、Angular。</p><h3 id="一、vue-js"><a href="#一、vue-js" class="headerlink" title="一、vue.js"></a>一、vue.js</h3><ul><li><p>优点：更轻量，单页面，简单易学</p></li><li><p>缺点：不支持 IE8</p></li></ul><h3 id="二、Angular"><a href="#二、Angular" class="headerlink" title="二、Angular"></a>二、Angular</h3><ul><li><p>优点：模块化功能强大、自定义 directive 非常灵活、双向数据绑定，依赖注入</p></li><li><p>缺点：比较笨重，学习成本高，不兼容 IE6/7</p></li></ul><h3 id="三、react"><a href="#三、react" class="headerlink" title="三、react"></a>三、react</h3><ul><li><p>优点：速度快、跨浏览器兼容、单向数据流、兼容性好</p></li><li><p>缺点：并不是一个完整的框架，需要加上 ReactRouter 和 Flux 才能完成。</p></li></ul><h1 id="陆续更新中…"><a href="#陆续更新中…" class="headerlink" title="陆续更新中…"></a>陆续更新中…</h1><h1 id="2020-展望"><a href="#2020-展望" class="headerlink" title="2020 展望"></a>2020 展望</h1>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>待添加</title>
      <link href="/2019/12/17/mian-shi-zhi-lu/"/>
      <url>/2019/12/17/mian-shi-zhi-lu/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=411214279&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="VUE项目常用方法总结"><a href="#VUE项目常用方法总结" class="headerlink" title="VUE项目常用方法总结"></a>VUE项目常用方法总结</h1><hr>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React小技巧汇总</title>
      <link href="/2019/11/06/react-zong-jie/"/>
      <url>/2019/11/06/react-zong-jie/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1347529350&auto=1&height=66"></iframe></div><p>自学 <code>React.js</code> 一段时间了，把使用过程遇到的小坑和小技巧记录下来，希望能够帮助到其他人。此文章是长篇大论你只有耐得住寂寞，禁得住诱惑才会有所成长……</p><h1 id="React-小技巧汇总"><a href="#React-小技巧汇总" class="headerlink" title="React 小技巧汇总"></a>React 小技巧汇总</h1><hr><h2 id="一、工具篇"><a href="#一、工具篇" class="headerlink" title="一、工具篇"></a>一、工具篇</h2><h3 id="1-显示-html"><a href="#1-显示-html" class="headerlink" title="1.显示 html"></a>1.显示 html</h3><pre><code>  &lt;div dangerouslySetInnerHTML={{ __html: LANG.auth_register_tips1 }}/&gt;</code></pre><h3 id="2-常用组件"><a href="#2-常用组件" class="headerlink" title="2.常用组件"></a>2.常用组件</h3><ul><li><code>axios</code>(http 请求模块，可用于前端任何场景，很强大)=&gt;<a href="https://www.jianshu.com/p/79816fa9c54f" target="_blank" rel="noopener">封装 axios</a></li><li><code>echarts-for-react</code>(可视化图表，别人基于 react 对 echarts 的封装，足够用了)=&gt;<a href="https://www.jianshu.com/p/f6c1c4618c22" target="_blank" rel="noopener">echarts-for-react</a></li><li><code>recharts</code>(另一个基于 react 封装的图表)=&gt;<a href="https://recharts.cosx.org/recharts" target="_blank" rel="noopener">官网</a></li><li><code>nprogress</code>(顶部加载条，蛮好用)</li><li><code>react-draft-wysiwyg</code>(别人基于 react 的富文本封装，如果找到其他更好的可以替换)</li><li><code>react-draggable</code>(拖拽模块，找了个简单版的)</li><li><code>screenfull</code>(全屏插件)</li><li><code>photoswipe</code>(图片弹层查看插件，不依赖 jQuery，还是蛮好用)</li><li><code>animate.css</code>(css 动画库)</li><li><code>redux Web</code> 应用是一个状态机，视图与状态是一一对应的.所有的状态，保存在一个对象里面</li><li><code>redux-logger</code> 日志</li><li><code>Reselect</code> 记忆组件</li><li><code>redux-thunk</code> 为了解决异步 action 的问题</li><li><code>redux-saga</code> 为了解决异步 action 的问题</li><li><code>react-router-redux</code> 保持路由与应用状态(state)同步</li><li><code>react-router-dom</code>路由基本组件 1).<a href="https://www.jianshu.com/p/8954e9fb0c7e" target="_blank" rel="noopener">在 React 中使用 react-router-dom 路由</a> 2).<a href="https://www.jianshu.com/p/19ef80d2e122" target="_blank" rel="noopener">react-router-dom 及组件生命周期</a></li></ul><h3 id="3-react-devtools-调试工具"><a href="#3-react-devtools-调试工具" class="headerlink" title="3.react-devtools 调试工具"></a>3.react-devtools 调试工具</h3><p><a href="https://github.com/facebook/react-devtools" target="_blank" rel="noopener">工具地址</a>:<a href="https://github.com/facebook/react-devtools" target="_blank" rel="noopener">https://github.com/facebook/react-devtools</a></p><p>或者 直接谷歌应用商店搜索<code>react-devtools</code>进行安装.</p><h2 id="二、组件通讯篇"><a href="#二、组件通讯篇" class="headerlink" title="二、组件通讯篇"></a>二、组件通讯篇</h2><p><img src="1.jpg" alt></p><p><strong>需要组件之进行通信的几种情况</strong></p><ul><li>redux 架构</li><li>父组件向子组件 —— props</li><li>子组件向父组件 —— props.funciton 接收参数</li><li>利用事件机制</li></ul><h3 id="1-父组件向子组件通信"><a href="#1-父组件向子组件通信" class="headerlink" title="1. 父组件向子组件通信"></a>1. 父组件向子组件通信</h3><p>React 数据流动是单向的,父组件向子组件通信也是最常见的;父组件通过 props 向子组件传递需要的信息</p><h3 id="2-子组件向父组件通信"><a href="#2-子组件向父组件通信" class="headerlink" title="2. 子组件向父组件通信"></a>2. 子组件向父组件通信</h3><ul><li>利用回调函数</li><li>利用自定义事件机制</li></ul><p><strong>子组件改变父组件的 state</strong></p><pre><code>  // 一般改变state值的一种方式  const { data } = this.state;  this.setState({ data: {...data, key: 1 } });  // 另外一种可以通过callback的方式改变state的值  this.setState(({ data }) =&gt; ({ data: {...data, key: 1 } }));  // 还可以  this.setState((state, props) =&gt; {  return { counter: state.counter + props.step };  });</code></pre><h3 id="3-跨级组件通信"><a href="#3-跨级组件通信" class="headerlink" title="3. 跨级组件通信"></a>3. 跨级组件通信</h3><ul><li>层层组件传递 props<blockquote><p>例如 A 组件和 B 组件之间要进行通信,先找到 A 和 B 公共的父组件,A 先向 C 组件通信,C 组件通过 props 和 B 组件通信,此时 C 组件起的就是中间件的作用</p></blockquote></li><li>使用 context<br>下面例子中的组件关系: ListItem 是 List 的子组件,List 是 app 的子组件</li></ul><p>ListItem.js</p><pre><code>  import React, { Component } from &#39;react&#39;;  import PropTypes from &#39;prop-types&#39;;  class ListItem extends Component {  // 子组件声明自己要使用context  static contextTypes = {        color: PropTypes.string,  }  static propTypes = {        value: PropTypes.string,  }  render() {        const { value } = this.props;        return (              &lt;li style={{ background: this.context.color }}&gt;              &lt;span&gt;{value}&lt;/span&gt;              &lt;/li&gt;        );  }  }  export default ListItem;</code></pre><p>List.js</p><pre><code>  import ListItem from &#39;./ListItem&#39;;  class List extends Component {  // 父组件声明自己支持context  static childContextTypes = {        color: PropTypes.string,  }  static propTypes = {        list: PropTypes.array,  }  // 提供一个函数,用来返回相应的context对象  getChildContext() {        return {              color: &#39;red&#39;,        };  }  render() {        const { list } = this.props;        return (              &lt;div&gt;              &lt;ul&gt;                    {                          list.map((entry, index) =&gt;                          &lt;ListItem key={`list-${index}`} value={entry.text} /&gt;,                    )                    }              &lt;/ul&gt;              &lt;/div&gt;        );  }  }  export default List;</code></pre><p>App.js</p><pre><code>  import React, { Component } from &#39;react&#39;;  import List from &#39;./components/List&#39;;  const list = [  {        text: &#39;题目一&#39;,  },  {        text: &#39;题目二&#39;,  },  ];  export default class App extends Component {  render() {        return (              &lt;div&gt;              &lt;List                    list={list}              /&gt;              &lt;/div&gt;        );  }  }</code></pre><h3 id="4-没有嵌套关系的组件通信"><a href="#4-没有嵌套关系的组件通信" class="headerlink" title="4. 没有嵌套关系的组件通信"></a>4. 没有嵌套关系的组件通信</h3><!-- + 使用自定义事件机制>在componentDidMount事件中,如果组件挂载完成,再订阅事件;在组件卸载的时候,在componentWillUnmount事件中取消事件的订阅;以常用的发布/订阅模式举例,借用Node.js Events模块的浏览器版实现 --><ul><li>组件间通信之 onRef 方法</li></ul><blockquote><p>组件间通信除了 props 外还有 onRef 方法，不过 React 官方文档建议不要过度依赖 ref。本文使用 onRef 语境为在表单录入时提取公共组件，在提交时分别获取表单信息。</p></blockquote><p>下面 demo 中点击父组件按钮可以获取子组件全部信息，包括状态和方法，可以看下 demo 中控制台打印。</p><pre><code>  // 父组件  class Parent extends React.Component {  testRef=(ref)=&gt;{  this.child = ref  console.log(ref) // -&gt; 获取整个Child元素  }  handleClick=()=&gt;{  alert(this.child.state.info) // -&gt; 通过this.child可以拿到child所有状态和方法  }  render() {  return &lt;div&gt;        &lt;Child onRef={this.testRef} /&gt;        &lt;button onClick={this.handleClick}&gt;父组件按钮&lt;/button&gt;  &lt;/div&gt;  }  }  // 子组件  class Child extends React.Component {  constructor(props) {  super(props)  this.state = {        info:&#39;快点击子组件按钮哈哈哈&#39;  }  }  componentDidMount(){  this.props.onRef(this)  console.log(this) // -&gt;将child传递给this.props.onRef()方法  }  handleChildClick=()=&gt;{  this.setState({info:&#39;通过父组件按钮获取到子组件信息啦啦啦&#39;})  }  render(){  return &lt;button onClick={this.handleChildClick}&gt;子组件按钮&lt;/button&gt;  }  }</code></pre><p><code>原理</code>：当在子组件中调用 onRef 函数时，正在调用从父组件传递的函数。this.props.onRef（this）这里的参数指向子组件本身，父组件接收该引用作为第一个参数：onRef = {ref =&gt;（this.child = ref）}然后它使用 this.child 保存引用。之后，可以在父组件内访问整个子组件实例，并且可以调用子组件函数。</p><h2 id="三、路由篇"><a href="#三、路由篇" class="headerlink" title="三、路由篇"></a>三、路由篇</h2><blockquote><p>使用 React 构建的单页面应用，要想实现页面间的跳转，首先想到的就是使用路由。在 React 中，常用的有两个包可以实现这个需求，那就是 react-router 和 react-router-dom。本文主要针对 react-router-dom 进行说明。</p></blockquote><h3 id="1、React-Router-中有三类组件"><a href="#1、React-Router-中有三类组件" class="headerlink" title="1、React Router 中有三类组件:"></a>1、React Router 中有三类组件:</h3><ul><li>router 组件（BrowserRouter，HashRouter）</li><li>route matching 组件（Route，Switch）</li><li>navigation 组件（Link）</li></ul><blockquote><p>基于 React Router 的 web 应用，根组件应该是一个 router 组件（BrowserRouter，HashRouter）。 项目中，react-router-dom 提供了和两种路由。两种路由都会创建一个 history 对象。如果我们的应用有服务器响应 web 的请求，我们通常使用<browserrouter>组件; 如果使用静态文件服务器，则我们应该使用<hashrouter>组件</hashrouter></browserrouter></p></blockquote><h3 id="2、HashRouter-和-BrowserRouter"><a href="#2、HashRouter-和-BrowserRouter" class="headerlink" title="2、HashRouter 和 BrowserRouter"></a>2、HashRouter 和 BrowserRouter</h3><p>其实就是路由的 hash 和 history 两种模式（要是不了解这两种模式之间的区别那就需要去恶补下啦）</p><p>并且这两个组件是路由的容器，<code>必须在最外层</code>—&gt;内部是 <code>Route</code></p><pre><code>  // hash模式  ReactDom.render(  &lt;HashRouter&gt;        &lt;Route path=&quot;/&quot; component={Home}/&gt;  &lt;/HashRouter&gt;  )  // history模式  ReactDom.render(  &lt;BrowserRouter&gt;        &lt;Route path=&quot;/&quot; component={Home}/&gt;  &lt;/BrowserRouter&gt;  )</code></pre><p><strong>下面说说 HashRouter 和 BrowserRouter 上的参数</strong></p><ul><li>basename 路由的基础链接，用来部署到非根目录下，比如你需要将项目部署到 <a href="http://www.xxxx.com/web" target="_blank" rel="noopener">www.xxxx.com/web</a> 下，则设置 basename=”/web”</li><li>getUserConfirmation 用来拦截 Prompt 组件，并且决定是否跳转</li><li>forceRefresh 用来设置是否强制浏览器整体刷新，默认值为 false</li><li>keLength 用来设置 location.key 的长度，默认是 6，可以自定义</li></ul><h3 id="3、Route"><a href="#3、Route" class="headerlink" title="3、Route"></a>3、Route</h3><p>Route 是路由的一个原材料，它是控制路径对应显示的组件</p><p>Route 的参数:</p><ul><li>path 跳转的路径</li><li>component 对应路径显示的组件</li><li>render 可以自己写 render 函数返回具体的 dom，而不需要去设置 component</li><li>location 传递 route 对象，和当前的 route 对象对比，如果匹配则跳转</li><li>exact 匹配规则，true 的时候则精确匹配。</li></ul><h3 id="4、Router"><a href="#4、Router" class="headerlink" title="4、Router"></a>4、Router</h3><p>低级路由，适用于任何路由组件，主要和 redux 深度集成，使用必须配合 history 对象</p><p>使用 Router 路由的目的是和状态管理库如 redux 中的 history 同步对接</p><pre><code>  &lt;Router history={history}&gt;  ...  &lt;/Router&gt;</code></pre><h3 id="5、Link-和-NavLink"><a href="#5、Link-和-NavLink" class="headerlink" title="5、Link 和 NavLink"></a>5、Link 和 NavLink</h3><p>两者都是跳转路由，NavLink 的参数更多些<br><strong>Link 的 api</strong></p><ul><li><p>to 有两种写法，表示跳转到哪个路由</p></li><li><p>字符串写法</p>  <link to="/a"></li><li><p>对象写法</p><pre><code>&lt;Link to={{      pathname: '/courses',      search: '?sort=name',      hash: '#the-hash',      state: { fromDashboard: true }      }}/&gt;</code></pre></li><li><p>replace 就是将 push 改成 replace</p></li><li><p>innerRef 访问 Link 标签的 dom</p></li></ul><p><strong>NavLink 的 api</strong></p><ul><li><p>Link 的所有 api</p></li><li><p>activeClassName 路由激活的时候设置的类名</p></li><li><p>activeStyle 路由激活设置的样式</p></li><li><p>exact 参考 Route，符合这个条件才会激活 active 类</p></li><li><p>strict 参考 Route，符合这个条件才会激活 active 类</p></li><li><p>isActive 接收一个回调函数，active 状态变化的时候回触发，返回 false 则中断跳转</p><pre><code>const oddEvent = (match, location) =&gt; {console.log(match,location)if (!match) {return false}console.log(match.id)return true}&lt;NavLink isActive={oddEvent} to=&quot;/a/123&quot;&gt;组件一&lt;/NavLink&gt;</code></pre></li></ul><ul><li><p>location 接收一个 location 对象，当 url 满足这个对象的条件才会跳转</p><pre><code>&lt;NavLink to=&quot;/a/123&quot; location={{ key:"mb5wu3", pathname:"/a/123" }}/&gt;</code></pre></li></ul><h3 id="6、Redirect"><a href="#6、Redirect" class="headerlink" title="6、Redirect"></a>6、Redirect</h3><p>Redirect 重定向很简单，我们直接看代码即可</p><pre><code>  // 基本的重定向  &lt;Redirect to=&quot;/somewhere/else&quot; /&gt;  // 对象形式  &lt;Redirect  to={{      pathname: "/login",      search: "?utm=your+face",      state: { referrer: currentLocation }      }}  /&gt;  // 采用push生成新的记录  &lt;Redirect push to=&quot;/somewhere/else&quot; /&gt;  // 配合Switch组件使用，form表示重定向之前的路径，如果匹配则重定向，不匹配则不重定向  &lt;Switch&gt;  &lt;Redirect from=&#39;/old-path&#39; to=&#39;/new-path&#39;/&gt;  &lt;Route path=&#39;/new-path&#39; component={Place}/&gt;  &lt;/Switch&gt;</code></pre><h3 id="7、Switch"><a href="#7、Switch" class="headerlink" title="7、Switch"></a>7、Switch</h3><p>路由切换，只会匹配第一个路由，可以想象成 tab 栏</p><p>Switch 内部只能包含 Route、Redirect、Router</p><pre><code>  &lt;Switch&gt;  &lt;Route exact path=&quot;/&quot; component={Home}/&gt;  &lt;Route path=&quot;/about&quot; component={About}/&gt;  &lt;Route path=&quot;/:user&quot; component={User}/&gt;  &lt;Route component={NoMatch}/&gt;  &lt;/Switch&gt;</code></pre><h3 id="8、withRouter"><a href="#8、withRouter" class="headerlink" title="8、withRouter"></a>8、withRouter</h3><p>当一个非路由组件也想访问到当前路由的 match,location,history 对象，那么 withRouter 将是一个非常好的选择，可以理解为将一个组件包裹成路由组件</p><pre><code>  import { withRouter } from &#39;react-router-dom&#39;  const MyComponent = (props) =&gt; {  const { match, location, history } = this.props  return (        &lt;div&gt;{props.location.pathname}&lt;/div&gt;  )  }  const FirstTest = withRouter(MyComponent);</code></pre><h3 id="9、history-对象"><a href="#9、history-对象" class="headerlink" title="9、history 对象"></a>9、history 对象</h3><p>用过 vue 的都知道，vue-router 有组件形式的导航，也有编程式导航，那 react-router 怎么使用 api 来控制前进后退和刷新呢？这就需要我们来说明下<code>history</code>对象的作用了其实在每个路由组件中我们可以使用<code>this.props.history</code>获取到<code>history</code>对象，也可以使用 withRouter 包裹组件获取，在 history 中封装了 push，replace，go 等方法，具体内容如下</p><pre><code>  History {  length: number;  action: Action;  location: Location;  push(path: Path, state?: LocationState): void; // 调用push前进到一个地址,可以接受一个state对象，就是自定义的路由数据  push(location: LocationDescriptorObject): void; // 接受一个location的描述对象  replace(path: Path, state?: LocationState): void; // 用页面替换当前的路径，不可再goBack  replace(location: LocationDescriptorObject): void; // 同上  go(n: number): void; // 往前走多少也页面  goBack(): void; // 返回一个页面  goForward(): void; // 前进一个页面  block(prompt?: boolean | string | TransitionPromptHook): UnregisterCallback;  listen(listener: LocationListener): UnregisterCallback;  createHref(location: LocationDescriptorObject): Href;  }</code></pre><p>这样我们想使用 api 来操作前进后退就可以调用 history 中的方法啦</p><p>其次也可通过暗转 history 库来实现，具体案例如下</p><pre><code>  import { BrowserRouter } from &#39;react-router-dom&#39;;  const history = require(&#39;history&#39;).createBrowserHistory();  /**  * forceRefresh: bool  * 作用：当浏览器不支持 HTML5 的 history API 时强制刷新页面。  */  const supportsHistory = &#39;pushState&#39; in window.history;  &lt;BrowserRouter        history={history}        basename=&quot;/&quot;        forceRefresh={!supportsHistory}        &gt;        {/* 路由入口 */}        ......  &lt;/BrowserRouter&gt;</code></pre><h3 id="10、-React-router-页面跳转的三种方式"><a href="#10、-React-router-页面跳转的三种方式" class="headerlink" title="10、 React-router 页面跳转的三种方式"></a>10、 React-router 页面跳转的三种方式</h3><p><a href="https://blog.csdn.net/Vue2018/article/details/100564775" target="_blank" rel="noopener">React-router 页面跳转的三种方式</a>:<a href="https://blog.csdn.net/Vue2018/article/details/100564775" target="_blank" rel="noopener">https://blog.csdn.net/Vue2018/article/details/100564775</a></p><h2 id="四、性能篇"><a href="#四、性能篇" class="headerlink" title="四、性能篇"></a>四、性能篇</h2><h3 id="1、react-组件的性能优化（渲染角度优化）"><a href="#1、react-组件的性能优化（渲染角度优化）" class="headerlink" title="1、react 组件的性能优化（渲染角度优化）"></a>1、react 组件的性能优化（渲染角度优化）</h3><h4 id="1、react-性能查看工具"><a href="#1、react-性能查看工具" class="headerlink" title="1、react 性能查看工具"></a>1、react 性能查看工具</h4><blockquote><p>再讲性能优化之前，我们需要先来了解一下如何查看 react 加载组件时所耗费的时间的工具，在 react 16 版本之前我们可以使用 React Perf 来查看。react16 版本之前，我们可以使用 react-addons-perf 工具来查看，而在最新的 16 版本，我们只需要在 url 后加上?react_pref。</p></blockquote><p>首先来了解一下<a href="https://reactjs.org/docs/perf.html" target="_blank" rel="noopener">react-addons-perf</a></p><p><code>react-addons-perf</code>这是 <code>React</code> 官方推出的一个性能工具包，可以打印出组件渲染的时间、次数、浪费时间等。</p><p>简单说几个 api，具体用法可参考<a href="https://reactjs.org/docs/perf.html" target="_blank" rel="noopener">官网</a>：</p><ul><li>Perf.start() 开始记录</li><li>Perf.stop() 结束记录</li><li>Perf.printInclusive() 查看所有设计到的组件 render</li><li>Perf.printWasted() 查看不需要的浪费组件 render</li></ul><p>大家可以在 chorme 中先安装 React Perf 扩展，然后在入口文件或者 redux 的 store.js 中加入相应的代码即可：<br><img src="2.jpg" alt></p><p>再来了解一下，在最新的 React16 版本中，在<code>url</code>后加上<code>?react_pref</code>，就可以在 chrome 浏览器的<code>performance</code>，我们可以查看<code>User Timeing</code>来查看组件的加载时间。点击 record 开始记录，注意记录时长不要超过 20s，否则可能导致 chrome 挂起。</p><p><img src="3.jpg" alt><br>大图<br><img src="4.jpg" alt></p><h4 id="2、单个-react-组件性能优化"><a href="#2、单个-react-组件性能优化" class="headerlink" title="2、单个 react 组件性能优化"></a>2、单个 react 组件性能优化</h4><ul><li>1、render 里面尽量减少新建变量和 bind 函数，传递参数是尽量减少传递参数的数量。</li></ul><blockquote><p>首先我们先思考一个问题，比如我要实现一个点击按钮使相应的 num 增加 1，我们有哪一些方法。<br>大家应该都能想到，无非就是三种，如下图：</p></blockquote><p><img src="5.jpg" alt></p><ul><li><p>第一种是在<code>构造函数</code>中绑定 this，</p></li><li><p>第二种是在 render()函数里面绑定 this，</p></li><li><p>第三种就是使用箭头函数，都能实现上述方法；<br>但是哪一种方法的性能最好，是我们要考虑的问题。应该大家都知道答案：<br><code>第一种的性能最好</code>。因为第一种，构造函数每一次渲染的时候<code>只会执行一遍</code>；<br>而第二种方法，在每次 render()的时候都会重新执行一遍函数；<br>第三种方法的话，每一次 render()的时候，都会生成一个新的箭头函数，即使两个箭头函数的内容是一样的。</p></li><li><p>2、定制 shouldComponentUpdate 函数</p></li></ul><blockquote><p>shouldComponentUpdate 是决定 react 组件什么时候能够不重新渲染的函数，但是这个函数默认的实现方式就是简单的返回一个 true。也就是说，默认每次更新的时候都要调用所用的生命周期函数，包括 render 函数，重新渲染。<br>我们来看一下下面的一个例子</p></blockquote><p><img src="6.jpg" alt></p><p>我们写两个组件，App 和 Demo 组件，并写两个方法，一个改变 App 中的 num 的值，一个是改变 title，我们在 Demo 的 render 中打印 render 函数。我们可以看到以下的效果：</p><p><img src="7.jpg" alt></p><p>我们可以清晰的看到虽然 demo 组件里的 title 值没有改变，但是还是 render 了。</p><p>为了解决这个问题，我们可以对 demo 组件进行如下的修改：</p><p><img src="8.jpg" alt></p><p>只有当 demo 的 title 值发生改变的时候，我们才去 render，我们可以看一下效果：</p><p><img src="9.jpg" alt></p><p>以上只是一个特别简单的一个对于 shouldComponentUpdate 的定制。在最新的 react 中，react 给我们提供了 React.PureComponent，官方也在早期提供了名为 react-addons-pure-render-mixin 插件来重新实现 shouldComponentUpdate 生命周期方法。<br><img src="10.jpg" alt></p><p>通过上述的方法的效果也是和我们定制 shouldComponentUpdate 的效果是一致的。但是我们要注意的是，这里的 PureRender 是浅比较的，因为深比较的场景是相当昂贵的。所以我们要注意我们在 1.1 中说到的一些注意点：不要直接为 props 设置对象或者数组、不要将方法直接绑定在元素上，因为其实函数也是对象</p><h3 id="2、redux-性能优化：reselect（数据获取时优化-待研究）"><a href="#2、redux-性能优化：reselect（数据获取时优化-待研究）" class="headerlink" title="2、redux 性能优化：reselect（数据获取时优化 待研究）"></a>2、redux 性能优化：reselect（数据获取时优化 待研究）</h3><p><a href="https://www.jianshu.com/p/1fcef4c892ba?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation" target="_blank" rel="noopener">react-redux 性能优化之 reselect</a></p><h3 id="3-1、分隔代码"><a href="#3-1、分隔代码" class="headerlink" title="3-1、分隔代码"></a>3-1、分隔代码</h3><h4 id="1、动态加载"><a href="#1、动态加载" class="headerlink" title="1、动态加载"></a>1、动态加载</h4><p>ES6 标准引入了 import 以方便我们静态加载模块。形式如：</p><pre><code>  import xxx from xxx.</code></pre><p>尽管 import 对于我们加载模块很有帮助，但是静态加载模块的方式一定程度上限制了我们来实现异步模块加载。不过，目前动态加载模块的 import()语法已处于提案阶段，并且 webpack 已将他引入并使用。import()提供了基于 Promise 的 API，因此，import()的返回值是一个完成状态或拒绝状态的 Promise 对象。形式如：</p><pre><code>  import(/* webpackChunkName: &#39;module&#39;*/ &quot;module&quot;)  .then(() =&gt; {        //todo  })  .catch(_ =&gt; console.log(&#39;It is an error&#39;))</code></pre><p>webpack 在编译时，识别到动态加载的 import 语法，则 webpack 会为当前动态加载的模块创建一个单独的 bundle。如果你使用的是官方的 Create-react-app 脚手架或 React 的服务端渲染框架 Next.js，那么可以直接使用动态 import 语法。如果你的脚手架是你自己配置的 webpack，那么你需要按照官方指南来设置，请移步[1]。</p><h4 id="2、动态加载-React-组件"><a href="#2、动态加载-React-组件" class="headerlink" title="2、动态加载 React 组件"></a>2、动态加载 React 组件</h4><p>当前最为流行的一种方法是使用 React-loadable [2]库提供的懒加载 React 组件。它利用 import()语法，使用 Promise 语法加载 React 组件。同时，React-loadable 支持 React 的服务端渲染。 通常，我们以如下方式实现组件：</p><pre><code>  import LazyComponet from &#39;LazyComponent&#39;;  export default function DemoComponent() {  return (        &lt;div&gt;              &lt;p&gt;demo component&lt;/p&gt;              &lt;AComponent /&gt;        &lt;/div&gt;  )  }</code></pre><p>在上面的例子中，假设 LazyComponet 在 DemoComponent 渲染时我们并不展示。但是因为我们使用 import 语法将 LazyComponet 导入，所以在编译时会将 LazyComponet 的代码与 DemoComponent 的代码打包到同一个 bundle 里面。 但是，这并不是我们想要的。所以我们可以通过使用 React-loadable 来懒加载 LazyComponet ，同时将 LazyComponet 的代码单独打包到一个 bundle 里面。我们可以看一下官网提供的例子：</p><pre><code>  import Loadable from &#39;react-loadable&#39;;  import Loading from &#39;./my-loading-component&#39;;  const LoadableComponent = Loadable({  loader: () =&gt; import(&#39;./my-component&#39;),  loading: Loading,  });  export default class App extends React.Component {  render() {  return &lt;LoadableComponent/&gt;;  }  }</code></pre><p>从例子中我们可以看到，react-loadable 使用动态 import()方法，并将导入的组件分配给 loader 属性。同时，react-loadable 提供了一个 loading 属性，以设置在加载组件时将展示的组件。</p><h4 id="3、高阶组件（HOC）"><a href="#3、高阶组件（HOC）" class="headerlink" title="3、高阶组件（HOC）"></a>3、高阶组件（HOC）</h4><p>高阶函数，可以传入函数作为参数的函数，如 map,sort,reduce。高阶组件包装了另一个组件的组件。</p><p>属性代理 （Props Proxy）<br>反向继承 （Inheritance Inversion）</p><h4 id="4、无状态组件"><a href="#4、无状态组件" class="headerlink" title="4、无状态组件"></a>4、无状态组件</h4><p>使用无状态组件，只从父组件接收 props，可以提高组件的渲染性能</p><pre><code>  const HelloWorld = (props) =&gt; &lt;div&gt;{props.name}&lt;/div&gt;ReactDOM.render(&lt;HelloWorld name=&quot;HelloWorld&quot; /&gt;,App)</code></pre><h4 id="5、componentWillReceiveProps-中取-props-的值"><a href="#5、componentWillReceiveProps-中取-props-的值" class="headerlink" title="5、componentWillReceiveProps 中取 props 的值"></a>5、componentWillReceiveProps 中取 props 的值</h4><p>注意应该取 nextProps,而不是 this.props</p><h4 id="6、bind-绑定函数"><a href="#6、bind-绑定函数" class="headerlink" title="6、bind 绑定函数"></a>6、bind 绑定函数</h4><p>利用 bind 绑定函数，是默认有 event 这个参数的，只是这个参数在给定参数之后</p><pre><code>  handleClockClick (id, e) {        console.log(id,e)        }  &lt;button onClick={this.handleClockClick.bind(this, 2)}&gt;Clock&lt;/button&gt;</code></pre><h4 id="7、ES6-类中，函数-this-不默认指向-对象"><a href="#7、ES6-类中，函数-this-不默认指向-对象" class="headerlink" title="7、ES6 类中，函数 this 不默认指向 对象"></a>7、ES6 类中，函数 this 不默认指向 对象</h4><ul><li><p>this.getDomNode 已经在低版本被移除了，现在设置 ref=xxx，然后使用 this.refs.xxx 访问 DOM 元素</p></li><li><p><code>ref</code> 可以赋值两种类型，一种是字符串，一种是函数, 字符串只能用在类组件，DOM 元素使用函数，纯函数组件不能使用 ref。旧版本 DOM 元素虽然可以使用 ref，但是 React 已不推荐。</p><pre><code>ref=&quot;test&quot; // this.refs.test 访问ref={test =&gt; this.test = test} // this.test 访问</code></pre></li></ul><h4 id="8、当只写属性名时，默认值为-true"><a href="#8、当只写属性名时，默认值为-true" class="headerlink" title="8、当只写属性名时，默认值为 true"></a>8、当只写属性名时，默认值为 true</h4><pre><code>  &lt;MyComponent isStock/&gt;// isStock 默认为 true</code></pre><h4 id="9、在-IE11-以下使用-React16"><a href="#9、在-IE11-以下使用-React16" class="headerlink" title="9、在 IE11 以下使用 React16"></a>9、在 IE11 以下使用 React16</h4><p>React16 依赖集合类型 Map 和 Set，在未提供原生支持的浏览器，需要使用一个 polyfill,例如 core-js 和 babel-polyfill<br>使用 core-js 支持</p><pre><code>  import &#39;core-js/es6/map&#39;;import &#39;core-js/es6/set&#39;;  import React from &#39;react&#39;;  import ReactDOM from &#39;react-dom&#39;;  ReactDOM.render(&lt;h1&gt;Hello, world!&lt;/h1&gt;,document.getElementById(&#39;root&#39;));</code></pre><h3 id="3-2、分隔代码"><a href="#3-2、分隔代码" class="headerlink" title="3-2、分隔代码"></a>3-2、分隔代码</h3><h4 id="1、componentDidMount-请求服务器数据"><a href="#1、componentDidMount-请求服务器数据" class="headerlink" title="1、componentDidMount 请求服务器数据"></a>1、componentDidMount 请求服务器数据</h4><p>在 componentDidMount 请求服务器数据并利用 setState 时应注意，在组件卸载 componentWillUnmount 应该把去求去掉</p><h4 id="2、利用-es6-rest-参数（形式为…变量名）传递可变数量的-props"><a href="#2、利用-es6-rest-参数（形式为…变量名）传递可变数量的-props" class="headerlink" title="2、利用 es6 rest 参数（形式为…变量名）传递可变数量的 props"></a>2、利用 es6 rest 参数（形式为…变量名）传递可变数量的 props</h4><pre><code>  // 定义子组件  const Demo = ({ prop1, prop2, ...restProps }) =&gt; (  &lt;div&gt;{ restProps.text}&lt;/div&gt;  )  // 父组件使用Demo  &lt;Demo prop1={xxx} prop2={xxx} text={xxx}/&gt;</code></pre><h4 id="3、setState-的其他用法"><a href="#3、setState-的其他用法" class="headerlink" title="3、setState 的其他用法"></a>3、setState 的其他用法</h4><pre><code>  // 一般改变state值的一种方式  const { data } = this.state;  this.setState({ data: {...data, key: 1 } });  // 另外一种可以通过callback的方式改变state的值  this.setState(({ data }) =&gt; ({ data: {...data, key: 1 } }));  // 还可以  this.setState((state, props) =&gt; {  return { counter: state.counter + props.step };  });</code></pre><h4 id="4、React-性能优化"><a href="#4、React-性能优化" class="headerlink" title="4、React 性能优化"></a>4、React 性能优化</h4><p>// React 性能优化有很多种方式，<br>// 那常见的一种就是在生命周期函数 shouldComponentUpdate 里面判断<br>// 某些值或属性来控制组件是否重新再次渲染。<br>// 判断一般的字符串，数字或者基础的对象，数组都还是比较好处理<br>// 那嵌套的对象或者数组就比较麻烦了，对于这种<br>// 推荐使用 lodash(或者其他的类似库)的 isEqual 对嵌套数组或对象进行判断<br>shouldComponentUpdate(nextProps, nextState) {<br>if (_.isEqual(nextState.columns, this.state.columns)) return false;<br>return true;<br>}</p><h4 id="5、React-进阶提高-技巧篇（28-个视频）链接"><a href="#5、React-进阶提高-技巧篇（28-个视频）链接" class="headerlink" title="5、React 进阶提高 - 技巧篇（28 个视频）链接"></a>5、React 进阶提高 - 技巧篇（28 个视频）链接</h4><p>介绍 React 的一些进阶知识点，一些开发上的实践技巧，一些工具库等。</p><p><a href="www.qiuzhi99.com/">视频更新地址：</a><a href="http://www.qiuzhi99.com/" target="_blank" rel="noopener">www.qiuzhi99.com/</a></p><h2 id="五、学习资料"><a href="#五、学习资料" class="headerlink" title="五、学习资料"></a>五、学习资料</h2><p><a href="doc.react-china.org">翻译后的官方文档，学技术一定要多看几遍文档</a>: doc.react-china.org<br><a href="https://www.reactjscn.com/" target="_blank" rel="noopener">react官网</a>:<a href="https://www.reactjscn.com/" target="_blank" rel="noopener">https://www.reactjscn.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE中使用echarts配合canvas绘制图例下载</title>
      <link href="/2019/10/24/vue-zhong-shi-yong-echarts-pei-he-canvas-hui-zhi-tu-li/"/>
      <url>/2019/10/24/vue-zhong-shi-yong-echarts-pei-he-canvas-hui-zhi-tu-li/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=411214279&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="VUE中使用echarts配合canvas绘制图例"><a href="#VUE中使用echarts配合canvas绘制图例" class="headerlink" title="VUE中使用echarts配合canvas绘制图例"></a>VUE中使用echarts配合canvas绘制图例</h1><hr><h2 id="什么是canvas"><a href="#什么是canvas" class="headerlink" title="什么是canvas?"></a>什么是<a href="https://www.runoob.com/html/html5-canvas.html" target="_blank" rel="noopener">canvas</a>?</h2><p>HTML5 <code>&lt;canvas&gt;</code> 元素用于图形的绘制，通过脚本 (通常是JavaScript)来完成.<br><code>&lt;canvas&gt;</code> 标签只是图形容器，您必须使用脚本来绘制图形。<br>你可以通过多种方法使用 canvas 绘制路径,盒、圆、字符以及添加图像。</p><h2 id="添加图例"><a href="#添加图例" class="headerlink" title="添加图例"></a>添加图例</h2><p>  <strong>html</strong></p><pre><code>&lt;img src=&quot;../../../static/img/xx.png&quot; id=&quot;zhinanzhen&quot; alt=&quot;指南针&quot; class=&quot;NS&quot; v-if=&quot;NSShow&quot; &gt;&lt;img src=&quot;../../../static/img/xx.png&quot; id=&quot;bilichi&quot; alt class=&quot;blc&quot; v-if=&quot;NSShow&quot; /&gt;</code></pre><p>  <strong>js</strong></p><pre><code>    //点击下载    downloadImg() {    let canvas = document.getElementsByTagName(&#39;canvas&#39;)[0]; // 获取地图元素    let tempcanvas = document.createElement(&#39;canvas&#39;);  // 创建地图元素    tempcanvas.width = 700;    tempcanvas.height = canvas.height;    // tempcanvas.style.backgroundColor = &#39;#fff&#39;    let ctx = tempcanvas.getContext(&#39;2d&#39;);     ctx.drawImage(canvas, (canvas.width - 700) / 2, 0, 700, canvas.height, 0, 0, 700, canvas.height);    //context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);    let img1 = document.getElementById(&quot;zhinanzhen&quot;);     img1.setAttribute(&#39;crossOrigin&#39;, &#39;anonymous&#39;); // 图片跨域    ctx.drawImage(img1, 550, 100, 82, 82)    //ctx.drawImage(img1, 左右, 上下, 长, 宽)    let img2 = document.getElementById(&quot;bilichi&quot;);    img2.setAttribute(&#39;crossOrigin&#39;, &#39;anonymous&#39;);    ctx.drawImage(img2, 50, canvas.height - 32, 165, 32)    let url = tempcanvas.toDataURL(&quot;image/png&quot;); // 生成图片 第二个参数0-1 默认0.94    // let url=tempcanvas.toDataURL(&quot;image/jpeg&quot;, 1.0);    var oA = document.createElement(&quot;a&quot;);    oA.download = &#39;&#39;;// 设置下载的文件名，默认是&#39;下载&#39;    oA.href = url;    document.body.appendChild(oA);    oA.click();    oA.remove(); // 下载之后把创建的元素删除     }     // 绘制底图     drawMap() {    let _this = this    this.$echarts.registerMap(&#39;maps&#39;, china);    mapcontainerPro ? mapcontainerPro.dispose() : &#39;&#39;    mapcontainerPro = this.$echarts.init(document.getElementById(&#39;mapcontainerPro&#39;));    mapcontainerPro.setOption({         title: [{        text: this.imgTitle,        left: &#39;center&#39;,        top: &#39;3%&#39;,        textStyle: {          color: &#39;black&#39;,          fontSize: 16        }      }, {        text: this.unit,        left: &#39;34%&#39;,        bottom: &#39;22%&#39;,        textStyle: {          fontSize: 16,          fontWeight: &#39;bold&#39;        }      }],      tooltip: {        show: true,        formatter: &#39;{b0}: {c0}&#39;      },      toolbox: {        show: false,        feature: {          dataView: {},          // saveAsImage: {          //   show: true,          //   excludeComponents: [&#39;toolbox&#39;],          //   pixelRatio: 2          // }        }      },      color: [&#39;#5B9CD6&#39;],      visualMap: {            // 图例        pieces: this.pieces,        inverse: false,       // 图例排序        orient: &#39;vertical&#39;, //图例方向        left: &#39;34%&#39;,        top: &#39;78%&#39;,        // min: 0,//最小        // max: this.range4,//最大        // splitNumber: 4,//共分5层        color: this.vColor,//颜色从高到低依次渐变        textStyle: {          fontSize: 16          // color: &#39;#00000&#39;,          //text:&#39;9jfhfhn&#39;        },      },      series: [        {          name: &#39;全国地图&#39;,          type: &#39;map&#39;,          aspectScale: 0.9, //地图长宽比          zoom: 1.1, //缩放比例          top: &#39;15%&#39;,          left: &#39;center&#39;,          label: {            normal: {              fontSize: 12            }          },          map: &#39;maps&#39;, // 自定义扩展图表类型          symbolSize: function (val) {            return val[2] / 10;          },          // label:{          //   show:true,          //   fontSize:12,          //   offset:[30,40]          // },          itemStyle: {            normal: {              label: {                show: true,                fontWeight: &quot;bolder&quot;,                fontSize: 12              },              areaColor: &#39;blue&#39;,              borderColor: &#39;black&#39;,              borderWidth: 0            },            emphasis: { label: { show: true } },          },          data: this.showData        }      ]    });  }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js搭建本地服务模拟数据</title>
      <link href="/2019/10/18/node.js-da-jian-ben-di-fu-wu-mo-ni-shu-ju/"/>
      <url>/2019/10/18/node.js-da-jian-ben-di-fu-wu-mo-ni-shu-ju/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=411214279&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="Node-js搭建本地服务模拟数据"><a href="#Node-js搭建本地服务模拟数据" class="headerlink" title="Node.js搭建本地服务模拟数据"></a>Node.js搭建本地服务模拟数据</h1><hr><h2 id="1-首先下载安装好Nodejs"><a href="#1-首先下载安装好Nodejs" class="headerlink" title="1. 首先下载安装好Nodejs"></a>1. 首先下载安装好Nodejs</h2><p><code>下载</code> : <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">Nodejs地址</a></p><h2 id="2-安装好了，打开cmd窗口，输入命令：npm-v-检验nodejs是否安装成功，如果出现以下界面则说明安装成功了"><a href="#2-安装好了，打开cmd窗口，输入命令：npm-v-检验nodejs是否安装成功，如果出现以下界面则说明安装成功了" class="headerlink" title="2. 安装好了，打开cmd窗口，输入命令：npm -v 检验nodejs是否安装成功，如果出现以下界面则说明安装成功了"></a>2. 安装好了，打开cmd窗口，输入命令：npm -v 检验nodejs是否安装成功，如果出现以下界面则说明安装成功了</h2><p><img src="3.jpg" alt></p><h2 id="3-输入命令-npm-install-http-server-g（在全局安装本地服务器）"><a href="#3-输入命令-npm-install-http-server-g（在全局安装本地服务器）" class="headerlink" title="3. 输入命令 npm install http-server -g（在全局安装本地服务器）"></a>3. 输入命令 npm install http-server -g（在全局安装本地服务器）</h2><p><img src="5.jpg" alt></p><h2 id="4-切换到你项目所在的路径"><a href="#4-切换到你项目所在的路径" class="headerlink" title="4. 切换到你项目所在的路径"></a>4. 切换到你项目所在的路径</h2><p><img src="66.jpg" alt></p><h2 id="5-命令行输入http-server-即可在此文件夹下打开服务器"><a href="#5-命令行输入http-server-即可在此文件夹下打开服务器" class="headerlink" title="5. 命令行输入http-server 即可在此文件夹下打开服务器"></a>5. 命令行输入http-server 即可在此文件夹下打开服务器</h2><p><img src="6.jpg" alt><br>域名和端口号是 127.0.0.1:8080、192.168.155.1:8080、192.168.1.122:8080</p><h2 id="6-在项目或者桌面下新建demo-gt-data-json文件"><a href="#6-在项目或者桌面下新建demo-gt-data-json文件" class="headerlink" title="6. 在项目或者桌面下新建demo =&gt;  data.json文件"></a>6. 在<code>项目</code>或者<code>桌面</code>下新建demo =&gt;  data.json文件</h2><p><img src="8.jpg" alt><br><img src="10.jpg" alt></p><h2 id="7-打开浏览器，输入域名端口号（上面三个域名端口号都可以用）和文件名称"><a href="#7-打开浏览器，输入域名端口号（上面三个域名端口号都可以用）和文件名称" class="headerlink" title="7. 打开浏览器，输入域名端口号（上面三个域名端口号都可以用）和文件名称"></a>7. 打开浏览器，输入域名端口号（上面三个域名端口号都可以用）和文件名称</h2><p><strong><a href="http://127.0.0.1:8080/data.json" target="_blank" rel="noopener">http://127.0.0.1:8080/data.json</a></strong><br><img src="12.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE项目常用方法总结</title>
      <link href="/2019/10/17/vue-xiang-mu-chang-yong-fang-fa-zong-jie/"/>
      <url>/2019/10/17/vue-xiang-mu-chang-yong-fang-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=411214279&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="VUE项目常用方法总结"><a href="#VUE项目常用方法总结" class="headerlink" title="VUE项目常用方法总结"></a>VUE项目常用方法总结</h1><hr><p><strong>1.什么是Webpack?</strong></p>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在 Vue 项目中使用 Echarts</title>
      <link href="/2019/10/17/echars-zai-vue-zhong-ru-he-shi-yong/"/>
      <url>/2019/10/17/echars-zai-vue-zhong-ru-he-shi-yong/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=411214279&auto=1&height=66"></iframe></div><p>废话不多说，那我们就看看如何在 Vue 的项目中使用 echarts……</p><h1 id="如何在-Vue-项目中使用-Echarts"><a href="#如何在-Vue-项目中使用-Echarts" class="headerlink" title="如何在 Vue 项目中使用 Echarts"></a>如何在 Vue 项目中使用 Echarts</h1><hr><h2 id="第一种方法-直接引入-Echarts"><a href="#第一种方法-直接引入-Echarts" class="headerlink" title="第一种方法 直接引入 Echarts"></a>第一种方法 直接引入 Echarts</h2><h3 id="安装-echarts-项目依赖"><a href="#安装-echarts-项目依赖" class="headerlink" title="安装 echarts 项目依赖"></a>安装 echarts 项目依赖</h3><pre><code>    npm install echarts --save    //或者    npm install echarts -S</code></pre><p>如果没有科学上网的朋友可以使用国内的淘宝镜像。</p><pre><code>    npm install -g cnpm --registry=https://registry.npm.taobao.org    cnpm install echarts -S</code></pre><ul><li><p>首先我们需要在自己的项目 main.js 中全局引入 Echarts</p><pre><code>  import echarts from &#39;echarts&#39;;  Vue.prototype.$echarts=echarts;</code></pre></li></ul><h3 id="创建图表"><a href="#创建图表" class="headerlink" title="创建图表"></a>创建图表</h3><pre><code>    &lt;template&gt;    &lt;div id=&quot;app&quot;&gt;      &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;/template&gt;    export default {      name: &quot;app&quot;,      methods: {        drawChart() {          // 基于准备好的dom，初始化echarts实例          let myChart = this.$echarts.init(document.getElementById(&quot;main&quot;));          // 指定图表的配置项和数据          let option = {            title: {              text: &quot;ECharts 入门示例&quot;            },            tooltip: {},            legend: {              data: [&quot;销量&quot;]            },            xAxis: {              data: [&quot;衬衫&quot;, &quot;羊毛衫&quot;, &quot;雪纺衫&quot;, &quot;裤子&quot;, &quot;高跟鞋&quot;, &quot;袜子&quot;]            },            yAxis: {},            series: [              {                name: &quot;销量&quot;,                type: &quot;bar&quot;,                data: [5, 20, 36, 10, 10, 20]              }            ]          };          // 使用刚指定的配置项和数据显示图表。          myChart.setOption(option);        }      },      mounted() {        this.drawChart();      }    };    &lt;/script&gt;</code></pre><h3 id="入门实例"><a href="#入门实例" class="headerlink" title="入门实例"></a>入门实例</h3><p>  <img src="4.jpg" alt></p><h2 id="第二种方法-使用-Vue-ECharts-组件"><a href="#第二种方法-使用-Vue-ECharts-组件" class="headerlink" title="第二种方法 使用 Vue-ECharts 组件"></a>第二种方法 使用 Vue-ECharts 组件</h2><h3 id="安装组件"><a href="#安装组件" class="headerlink" title="安装组件"></a>安装组件</h3><pre><code>  npm install vue-echarts -S</code></pre><h3 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h3><pre><code>  &lt;template&gt;    &lt;div id=&quot;app&quot;&gt;      &lt;v-chart class=&quot;my-chart&quot; :options=&quot;bar&quot;/&gt;    &lt;/div&gt;  &lt;/template&gt;  &lt;script&gt;  // 在对应组件内引用或者main.js全局引用  import ECharts from &quot;vue-echarts/components/ECharts&quot;;  import &quot;echarts/lib/chart/bar&quot;;`  export default {    name: &quot;App&quot;,    components: {      &quot;v-chart&quot;: ECharts    },    data: function() {      return {        bar: {          title: {            text: &quot;ECharts 入门示例&quot;          },          tooltip: {},          legend: {            data: [&quot;销量&quot;]          },          xAxis: {            data: [&quot;衬衫&quot;, &quot;羊毛衫&quot;, &quot;雪纺衫&quot;, &quot;裤子&quot;, &quot;高跟鞋&quot;, &quot;袜子&quot;]          },          yAxis: {},          series: [            {              name: &quot;销量&quot;,              type: &quot;bar&quot;,              data: [5, 20, 36, 10, 10, 20]            }          ]        }      };    }  };  &lt;/script&gt;  &lt;style&gt;  .my-chart {    width: 800px;    height: 500px;  }  &lt;/style&gt;</code></pre><h3 id="入门实例-1"><a href="#入门实例-1" class="headerlink" title="入门实例"></a>入门实例</h3><p><img src="1679c3f7aa381aa7" alt></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="问题1：父子组件传值，容易造成点开子组件后，echarts-图不出现"><a href="#问题1：父子组件传值，容易造成点开子组件后，echarts-图不出现" class="headerlink" title="问题1：父子组件传值，容易造成点开子组件后，echarts 图不出现"></a>问题1：父子组件传值，容易造成点开子组件后，echarts 图不出现</h3><pre><code>原因：因此在另一个父组件进行应用的时候，他是首屏就加载，数据不变动。但是当数据变动之后，无法自动的更新图表。由于 mounted 只会在挂载的时候执行一次，因此无法后续进行更新。**解决办法：给父组件加上一个 v-if，使子组件重新渲染**  &lt;template&gt;   &lt;div&gt;   &lt;envy-pie :voltage=&quot;voltage&quot; v-if=&quot;flag&quot;&gt;   &lt;/div&gt;  &lt;/template&gt;    //js部分    data () {          return {            voltage: [],            flag: false          }        },        components: {          envyPie        },        methods: {          getEnvyContent () {            axios.get(&#39;../../../static/mock/envy.json&#39;).then(this.getEnvyContentSucc)          },          getEnvyContentSucc (res) {            if (res) {              const data = res.data              this.voltage = res.data.capacity_by_voltage              this.flag = true            }          }        },        mounted() {          this.getEnvyContent()        }</code></pre><h3 id="问题2-自动缩放"><a href="#问题2-自动缩放" class="headerlink" title="问题2:自动缩放"></a>问题2:自动缩放</h3><p>  Echarts 本身是不支持自动缩放的，但是 Echarts 为我们提供了 resize 方法。</p><pre><code>    //在**调用方法**中加入下面这行代码    window.addEventListener(&quot;resize&quot;, this.chart.resize);</code></pre><h3 id="问题3-支持数据自动刷新"><a href="#问题3-支持数据自动刷新" class="headerlink" title="问题3:支持数据自动刷新"></a>问题3:支持数据自动刷新</h3><p><a href="https://juejin.im/post/5ab220b8f265da237c68ca11" target="_blank" rel="noopener">原文链接</a></p><pre><code>因为 Echarts 是数据驱动的，这意味着只要我们重新设置数据，那么图表就会随之重新渲染，这是实现本需求的基础。我们再设想一下，如果想要支持数据的自动刷新，必然需要一个监听器能够实时监听到数据的变化然后告知 Echarts 重新设置数据。所幸 Vue 为我们提供了==watcher==功能，通过它我们可以很方便的实现上述功能  //在Chart.vue中加入watch  watch: {        //观察option的变化     option: {             handler(newVal, oldVal) {                 if (this.chart) {                    if (newVal) {            t          his.chart.setOption(newVal);                    } else {                      this.chart.setOption(oldVal);   }                } else {                      this.init();             } },                deep: true //对象内部属性的监听，关键。            }         }</code></pre><h3 id="问题4-图表太丑怎么破，ECharts神器带你飞！"><a href="#问题4-图表太丑怎么破，ECharts神器带你飞！" class="headerlink" title="问题4:图表太丑怎么破，ECharts神器带你飞！"></a>问题4:图表太丑怎么破，ECharts神器带你飞！</h3><p><a href="https://juejin.im/post/59dcb823f265da432d270f26" target="_blank" rel="noopener">原文链接</a></p><h3 id="问题5-Echarts-x轴文本内容太长的几种解决方案"><a href="#问题5-Echarts-x轴文本内容太长的几种解决方案" class="headerlink" title="问题5:Echarts x轴文本内容太长的几种解决方案"></a>问题5:Echarts x轴文本内容太长的几种解决方案</h3><p><a href="https://juejin.im/post/5d255d69f265da1b80206db1" target="_blank" rel="noopener">原文链接</a></p><h3 id="Echars-遇到问题汇总…"><a href="#Echars-遇到问题汇总…" class="headerlink" title="Echars 遇到问题汇总…."></a>Echars 遇到问题汇总….</h3><p><a href="https://www.cnblogs.com/padding1015/p/9936533.html" target="_blank" rel="noopener">原文链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TS+VUE项目搭建</title>
      <link href="/2019/10/16/ts-vue-xiang-mu-da-jian/"/>
      <url>/2019/10/16/ts-vue-xiang-mu-da-jian/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=574919767&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="TS-VUE项目搭建"><a href="#TS-VUE项目搭建" class="headerlink" title="TS+VUE项目搭建"></a>TS+VUE项目搭建</h1><hr><p>自尤大推出vue对typescript的支持后，一直想开箱尝试，对于前端sr来说，vue的顺滑加上ts的面向对象，想着就非常美好~ 终于在两个月前，找到了个机会尝试了一把vue+ts的组合。 开文记录下vue和ts整合之旅和遇到的一些坑。</p><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>应该大部分人都知道vue，毕竟如今vue是与react肩并肩的存在，所以就不过多介绍啦。</p><p><a href="https://cn.vuejs.org/index.html" target="_blank" rel="noopener">vue中文官网</a> 官网上的教程就是最好的入门教程</p><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>我在前几篇文章就一直有在宣传typescript，简单列举下ts的优点</p><ol><li><p>始于JavaScript，归于JavaScript,typescript是JavaScript的超集，所以它可以重用JavaScriptd代码,使用JavaScript的库</p></li><li><p>JavaScript用的优点它都有，跨浏览器、跨操作系统等</p></li><li><p>面向对象的编程思想,强大的类型检查</p></li></ol><p>开源大法好</p><p>要说缺点的话，那就是不太适合太小的项目。<br>就凭这些优点，足够我们愉快的玩耍~</p><h2 id="TS安装"><a href="#TS安装" class="headerlink" title="TS安装"></a>TS安装</h2><p> 先将node安装，然后在通过npm安装ts的包</p><pre><code>  npm install -g typescript  tsc -v //查看ts的版本号</code></pre><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><h3 id="执行安装命令"><a href="#执行安装命令" class="headerlink" title="执行安装命令"></a>执行安装命令</h3><pre><code>npm install -g @vue/cli</code></pre><p> 安装完成后，可以通过 vue create 快速创建一个新项目的脚手架，或者直接通过 vue serve 构建新想法的原型。</p><h3 id="创建项目-1"><a href="#创建项目-1" class="headerlink" title="创建项目"></a>创建项目</h3><pre><code>vue create vue-ts  //vue-ts 是我们的项目名称，执行后如下![](1.jpg)</code></pre><p>可看到有这么几个选项，xiaoli这个选项是我之前创建的，稍后会介绍；default这个后面写着 babel eslint ，表示若选择这个，那么只会引入babel和 ealint；manually select features顾名思义，选择我们想要的。那么我们选择第三个</p><p><img src="2.jpg" alt></p><p>可看到列表里有很多选项，这里是多项选择，按<code>上/下键</code>切换选项，<code>空格键</code>选择该选项，<code>enter</code>键进入下一步。你可以根据项目的实际情况，选择相应的选项。我们以vue+ts为主，所以我们选择 babel typescript router vuex 这几个，选择完后，如下</p><p><img src="3.jpg" alt></p><p>接下来会有好几个yes or no 的选项，大家根据自己项目的需要来选择就可以，最后一步，<code>Save this as a preset for future projects?</code> 若选择yes，就会将我们之前的选择存储起来，作为一个预设选项，方便后续一键创建新项目。所有步骤选完，回车，便开始创建项目文件结构和拉取npm包</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p> <strong>项目结构如下</strong></p><p><img src="4.jpg" alt></p><p><strong>public:</strong> 用于存放静态文件，<code>index.html</code>入口文件就放在里面，这个文件夹下的文件不会纳入webpack的打包中；<br><strong>src：</strong>存放vue项目工程文件，其中已经帮我们关联好router和vuex，文件结构非常简洁<br>其他：webpack、babel等配置文件</p><h2 id="与TypeScript复用"><a href="#与TypeScript复用" class="headerlink" title="与TypeScript复用"></a>与TypeScript复用</h2><p>项目在构建中，已经引入 <code>vue-class-component</code> ，用于对ts的支持，或者使用 <code>vue-property-decorator</code>,这个库是在之前那个的基础上扩展。</p><p>以下列举tsvue写法的各种变化</p><h3 id="组件声明"><a href="#组件声明" class="headerlink" title="组件声明"></a>组件声明</h3><pre><code> import { Component, Prop, Vue, Watch } from &#39;vue-property-decorator&#39;;  @Component  export default class Test extends Vue {  }</code></pre><h3 id="data对象"><a href="#data对象" class="headerlink" title="data对象"></a>data对象</h3><p>通过构造函数创建data里的数据</p><pre><code>  import { Component, Prop, Vue, Watch } from &#39;vue-property-decorator&#39;;  @Component  export default class Test extends Vue {      private name: string;      constructor() {          super();          this.name = &#39;xiaoli&#39;;      }  }</code></pre><p><strong>data里的数据使用方式如下</strong><br>      public getName(){<br>          return this.name<br>      }    </p><h3 id="Prop声明"><a href="#Prop声明" class="headerlink" title="Prop声明"></a>Prop声明</h3><pre><code>  @Prop() public msg: string;  @Prop({ default: &#39;default value&#39; }) propB: string  @Prop([String, Boolean]) propC: string | boolean</code></pre><h3 id="生命周期函数使用"><a href="#生命周期函数使用" class="headerlink" title="生命周期函数使用"></a>生命周期函数使用</h3><pre><code>  public created(): void {      console.log(&#39;created&#39;);  }  public mounted():void{      console.log(&#39;mounted&#39;)  }</code></pre><h3 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h3><p>js下是需要在method对象中声明方法，现变成如下</p><pre><code>  public clickFunc(): void {      console.log(this.name)      console.log(this.msg)  }</code></pre><h3 id="Watch监听属性"><a href="#Watch监听属性" class="headerlink" title="Watch监听属性"></a>Watch监听属性</h3><pre><code>  @Watch(&#39;name&#39;,{ immediate: true, deep: true })  public onChildChanged(val: string, oldVal: string) {      console.log(&#39;watch new name=&#39; + val);  }</code></pre><h3 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h3><pre><code>  public get allname() {      return &#39;computed &#39; + this.name;  } </code></pre><p>allname是计算后的值，name是被监听的值</p><h3 id="emit事件"><a href="#emit事件" class="headerlink" title="emit事件"></a>emit事件</h3><pre><code>  @Emit()    addToCount(n: number) {      this.count += n    }    @Emit(&#39;reset&#39;)    resetCount() {      this.count = 0    }</code></pre><p>第一个的事件名称为 add-to-count,n为传过去的参数；第二个事件名为reset-count,参数为空</p><h3 id="指令和过滤器"><a href="#指令和过滤器" class="headerlink" title="指令和过滤器"></a>指令和过滤器</h3><blockquote><p>我尝试了下，发现之前在入口文件直接引入指令或者过滤器的方式不管用了，因为用了ts后，组件的作用域跟之前的不一样了，然后我找了官方的issue，截图如下.</p></blockquote><p><img src="5.jpg" alt></p><p><strong>一个自定义指令</strong></p><pre><code>  // ./directive/index.ts  export const focus = {      // 当被绑定的元素插入到 DOM 中时……      inserted: function (el:HTMLElement) {          // 聚焦元素          el.focus()        }  }</code></pre><p><strong>一个过滤器</strong></p><pre><code>  // ./filter/index.ts  export const capitalize = function (value:string) {      if (!value) return &#39;&#39;      value = value.toString()      return value.charAt(0).toUpperCase() + value.slice(1)  }</code></pre><p><strong>组件中使用</strong></p><pre><code>  import { capitalize }from &#39;@/filter/index&#39;  import { focus } from &#39;@/directive/index&#39;  @Component({      filters:{capitalize},      directives:{focus}  })  export default class Test extends Vue {}  复制代码&lt;div&gt;      &lt;input v-focus v-model=&quot;modelData&quot;&gt;      &lt;div&gt;{{modelData | capitalize}}&lt;/div&gt;  &lt;/div&gt;</code></pre><h2 id="Vuex与TS的糅合"><a href="#Vuex与TS的糅合" class="headerlink" title="Vuex与TS的糅合"></a>Vuex与TS的糅合</h2><p>因为vuex是个可选的，所以单独列出来。首先需要引用 <code>vuex-class</code> 库，该库有如下几个模块</p><pre><code>  import {      namespace,      Action,      Getter,      Mutation,      State  } from &#39;vuex-class&#39;;</code></pre><p>分别对应vuex中的 action、getter、mutation等，使用ts对vuex的影响主要在组件对vuex的调用上，vuex的定义还是按照之前的写法即可 </p><pre><code>  @State(&#39;foo&#39;) stateFoo  @State(state =&gt; state.bar) stateBar  @Getter(&#39;foo&#39;) getterFoo  @Action(&#39;foo&#39;) actionFoo  @Mutation(&#39;foo&#39;) mutationFoo  @someModule.Getter(&#39;foo&#39;) moduleGetterFoo  // If the argument is omitted, use the property name  // for each state/getter/action/mutation type  @State foo  @Getter bar  @Action baz  @Mutation qu</code></pre><p>若不想使用vuex定义的方法名，可以自定义属性名，因为都是定义在当前this上，所以直接使用this调用即可</p><pre><code>  this.getterFoo // -&gt; store.getters.foo  this.actionFoo({ value: true }) // -&gt; store.dispatch(&#39;foo&#39;, { value: true })</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p> ……</p>]]></content>
      
      
      <categories>
          
          <category> TS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TS基础总结</title>
      <link href="/2019/10/15/ts-xue-xi-zong-jie/"/>
      <url>/2019/10/15/ts-xue-xi-zong-jie/</url>
      
        <content type="html"><![CDATA[<div align="middle"><!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=411214279&auto=1&height=66"></iframe> --><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28854182&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="ts-基础总结"><a href="#ts-基础总结" class="headerlink" title="ts 基础总结"></a>ts 基础总结</h1><hr><p><strong>ts 有什么用</strong></p><p>类型检查, 拥抱 es6，支持部分的 esNext 草案，直接编译到原生 js、引入新的语法糖</p><p><strong>为什么用 ts</strong></p><blockquote><p>TypeScript 的设计目的应该是解决 JavaScript 的“痛点”：弱类型和没有命名空间，导致很难模块化，不适合开发大型程序。另外它还提供了一些语法糖来帮助大家更方便地实践面向对象的编程。<br>typescript 不仅可以约束我们的编码习惯，还能起到注释的作用，当我们看到一函数后我们立马就能知道这个函数的用法，需要传什么值，返回值是什么类型一目了然，对大型项目的维护性有很大的提升。</p></blockquote><p><strong>编译报错， 会生成编译结果么？</strong></p><p>答案是肯定的,当然可以在 tsconfig.json 的配置， noEmitONError</p><h1 id="基础总结"><a href="#基础总结" class="headerlink" title="基础总结"></a>基础总结</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>boolean 、number、string、null、 undefined、 Symbol</li><li>undefined 和 null 类型的数据只能被赋值 undefined 和 null， 但是这个类型是所有类型的子类型</li><li>void 空类型<br>// undefined 和 null 是所有类型子类型，都可以赋值<br>let num: Symbol = undefined;ss<br>let num: number = undefined;<br>// undefined 类型， 只能给 undefined<br>let u: undefined = undefined;<br>let n: null = null;</li><li>any 和类型推断<br>// 在 ts 中，变量在声明的时候，如果没有定义其类型，会被识成默认类型<br>let str;<br>str = ‘I am strgting’;<br>str = 1024;<br>// 未定义类型，直接赋值<br>let num= 124;<br>// 等同于 let num:number = 124, 在后面代码如果赋予 num 一个 string 会被报错</li></ul><h2 id="多个可能属性"><a href="#多个可能属性" class="headerlink" title="多个可能属性"></a>多个可能属性</h2><pre><code>  //只能访问可能属性的共有属性  function getLength(param: string| number) {      return param.length;  }  // 会报错， 因为 length不是 sting和number类型的共有属性  // 技巧--》 使用类型别名  type possibleType = string | number;  function getLength(param: possibleType) {      return param.length;  }</code></pre><h2 id="接口的概念"><a href="#接口的概念" class="headerlink" title="接口的概念"></a>接口的概念</h2><ul><li>在 ts 中，interface 包括对行为的抽象，由类去实现（implements）</li><li>也包括对对象轮廓的描述</li></ul><h2 id="对象-interface-》动态属性"><a href="#对象-interface-》动态属性" class="headerlink" title="对象 interface -》动态属性"></a>对象 interface -》动态属性</h2><p>必选参数和可选参数的类型是动态属性类型的子集，所有在动态属性类型设置的时候要设置上所有类型</p><p>只读属性的约束力<br>注意点： 只读属性的约束力在于第一次给对象赋值的时候，而不是给属性赋值的时候 readonly 和 const 的区别： const 是变量， readonly 是属性</p><h2 id="接口-》抽象方法的实现"><a href="#接口-》抽象方法的实现" class="headerlink" title="接口-》抽象方法的实现"></a>接口-》抽象方法的实现</h2><pre><code>  export interface ISRequest {    fetch(url: string, arg?: Object, callback?: Function): Promise&lt;Object&gt;;  }  export class SafeRequest implements ISRequest {        public async fetch(url: string, arg, callback?: Function): Promise&lt;Object&gt; {          return new Promise((resolve, reject) =&gt; {          })  }</code></pre><h2 id="用接口表示数组"><a href="#用接口表示数组" class="headerlink" title="用接口表示数组"></a>用接口表示数组</h2><pre><code>  interface NumberArray {        [index: any]: number    }    let numArr: NumberArray = [1, 2, 3]</code></pre><h2 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h2><ul><li><p>可选参数, 必须在必选参数后面</p></li><li><p>参数默认值<br>function buildName(firstName: string, lastName?: string) {</p><p> }</p></li><li><p>添加默认值的参数识别为可选参数</p></li><li><p>剩余参数</p></li></ul><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><h2 id="疑惑–》-声明文件"><a href="#疑惑–》-声明文件" class="headerlink" title="疑惑–》 声明文件"></a>疑惑–》 声明文件</h2><p>当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。<br>声明文件在哪里？</p><ul><li>与 npm 包绑定在一起</li><li>npm 包的维护者并没有提供声明文件， 只能由其他人将声明文件发布到@types 里面</li><li>自己写个声明文件</li></ul><p>npm 包的声明文件 和全局变量的声明文件<br>在 npm 包的声明文件中，使用 declare 不再会声明一个全局变量，而只会在当前文件中声明一个局部变量。只有在声明文件中使用 export 导出，然后在使用方 import 导入后，才会应用到这些类型声明。</p><p>######declare global<br>使用 declare global 可以在 npm 包或者 UMD 库中扩展全局变量的类型</p><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">内置对象查询–》点击</a><br>ESMAScript 提供了 Boolean、Error、Date、RegExp</p><pre><code>   interface obj = {        param: Function        param: Promise    }</code></pre><p>枚举–》 数据的双向映射</p><pre><code>    enum companyList= {1: &#39;aaa&#39;, 2: &#39;bbb&#39;}    var companyList = {        1: &#39;aaa&#39;,        2: &#39;bbb&#39;,        aaa: 1,        bbb: 2    }</code></pre><h2 id="Vue-in-Typescript"><a href="#Vue-in-Typescript" class="headerlink" title="Vue in Typescript"></a>Vue in Typescript</h2><h3 id="三大利器"><a href="#三大利器" class="headerlink" title="三大利器"></a>三大利器</h3><ul><li>vue-component-class</li><li>方法可以直接声明为类成员方法。</li><li>可以将计算属性声明为类属性访问器。</li><li>默认 data 被当作类属性</li><li>data ， render 和 vue 的生命周期的钩子直接是类成员的方法，保留这些命名，不要冲突</li><li>对于其他的配置项，例如 prop、componets 等传递给装饰器函数</li></ul><pre><code>import Vue from &#39;vue&#39;;import Component from &#39;vue-componet-class&#39;;Component.resgisterHooks([    &#39;beforeRouteEnter&#39;])@Componnet({    props: {    },    components: {    }})export default class App extends Vue {    // aa = &#39;&#39;;    // 类型推断aa是个string， 后面aa只能赋值aa类型    // 所以最好使用先声明后    //  data   public tableModelItems: Array&lt;any&gt;;   constructor() {       super();       this.tableModelItems = [];   }   // computed  public get filterTableData() {    return this.tableData.filter((i: any) =&gt; i.refundStatus === 0).length    // 方法    // 声明周期    // 此时需要路由函数的生命周期钩子咋办    beforeRouteEnterf() {        next() // 一定要写，否则玩不下去，为什么？    }}}- vue-property-decorator(依赖vue-component-class提供了更多了装饰器，代码更加显示 )- @Emit- @Inject- @Prop- @Provide- @Watch- vuex-class（连接了vue和vuex）## 还没搞定的bug</code></pre><h3 id="错误–》-类型报错"><a href="#错误–》-类型报错" class="headerlink" title="错误–》 类型报错"></a>错误–》 类型报错</h3><ul><li>添加script的类型<pre><code>&lt;script lang=&quot;ts&quot;&gt;&lt;/script&gt;&lt;!--否则下面的类型报错--&gt;</code></pre></li></ul><h3 id="错误之–》Vue中挂载propoty出错（如果还是爆红，重启ide）"><a href="#错误之–》Vue中挂载propoty出错（如果还是爆红，重启ide）" class="headerlink" title="错误之–》Vue中挂载propoty出错（如果还是爆红，重启ide）"></a>错误之–》Vue中挂载propoty出错（如果还是爆红，重启ide）</h3><p>声明再挂载</p><pre><code>    &lt;!--inject--&gt;      import _Vue from &#39;vue&#39;      import moment from &quot;moment&quot;;      export default {        install(Vue: typeof _Vue, options: any) {          Vue.prototype.$moment = moment;          Vue.prototype.$log = () =&gt; {            console.log(new Date())          }        }      }    &lt;!--types--&gt;      import Vue from &#39;vue&#39;      declare module &#39;vue/types/vue&#39; {        interface Vue {          $moment: Function          $log: Function        }      }</code></pre><h3 id="ts中不能识别-vue文件"><a href="#ts中不能识别-vue文件" class="headerlink" title="ts中不能识别.vue文件"></a>ts中不能识别.vue文件</h3><p> <strong>TypeScript 默认只识别 .ts 文件，不识别 .vue 文件, 乖乖的写 import Component from ‘components/component.vue’</strong><br><img src="1.jpg" alt></p><h3 id="vuex-class的Emit传参数给父组件报错"><a href="#vuex-class的Emit传参数给父组件报错" class="headerlink" title="vuex-class的Emit传参数给父组件报错"></a>vuex-class的Emit传参数给父组件报错</h3><pre><code>@emit(&quot;reset&quot;)reset(role, this.formData){}&lt;!--此时报错--&gt;</code></pre><p><img src="2.jpg" alt></p><h3 id="错误–-gt-可选参数爆红"><a href="#错误–-gt-可选参数爆红" class="headerlink" title="错误–&gt; 可选参数爆红"></a>错误–&gt; 可选参数爆红</h3><p><img src="3.jpg" alt></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://www.tslang.cn/docs/handbook/basic-types.html" target="_blank" rel="noopener">ts的官网</a></li><li><a href="https://juejin.im/post/5ba75b355188255c5e66e4d3" target="_blank" rel="noopener">vue+ts快速上手</a></li><li><a href="https://ts.xcatliu.com/" target="_blank" rel="noopener">ts通俗易懂，比较清晰的文档</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247490464&idx=1&sn=0c75aaab12002c76198a8d6f183cd686&chksm=f951aee3ce2627f50a5ac6799964919e54a7298288f8bf881931d7c6769b05e302418bdb8051&scene=27#wechat_redirect" target="_blank" rel="noopener">尤大大对于ts+vue的看法</a></li><li><a href="https://juejin.im/post/5a9c004a6fb9a028b92c9e91#heading-7" target="_blank" rel="noopener">蚂蚁金服的ts实践</a><br>……</li></ul>]]></content>
      
      
      <categories>
          
          <category> TS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>26个常用易忘CSS小技巧</title>
      <link href="/2019/09/22/26-ge-chang-yong-yi-wang-css-xiao-ji-qiao/"/>
      <url>/2019/09/22/26-ge-chang-yong-yi-wang-css-xiao-ji-qiao/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28854182&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><hr><p>26个常用易忘CSS小技巧</p><p>收集于平时常用但易忘的CSS实现方法…..</p><p><strong>1.解决inline-block元素设置overflow:hidden属性导致相邻行内元素向下偏移</strong></p><pre><code>.wrap {  display: inline-block;  overflow: hidden  vertical-align: bottom}</code></pre><p><strong>2.超出部分显示省略号</strong></p><pre><code>// 单行文本.wrap {  overflow:hidden;/*超出部分隐藏*/  text-overflow:ellipsis;/*超出部分显示省略号*/  white-space:nowrap;/*规定段落中的文本不进行换行 */}// 多行文本.wrap {    width: 100%;    overflow: hidden;    display: -webkit-box;   //将对象作为弹性伸缩盒子模型显示  *必须结合的属性*    -webkit-box-orient: vertical;   //设置伸缩盒对象的子元素的排列方式  *必须结合的属性*    -webkit-line-clamp: 3;   //用来限制在一个块元素中显示的文本的行数    word-break: break-all;   //让浏览器实现在任意位置的换行 *break-all为允许在单词内换行*}</code></pre><p><strong>3.css实现不换行、自动换行、强制换行</strong></p><pre><code>//不换行.wrap {  white-space:nowrap;}//自动换行.wrap {  word-wrap: break-word;  word-break: normal;}//强制换行.wrap {  word-break:break-all;}</code></pre><p><strong>4.CSS实现文本两端对齐</strong></p><pre><code>.wrap {    text-align: justify;    text-justify: distribute-all-lines;  //ie6-8    text-align-last: justify;  //一个块或行的最后一行对齐方式    -moz-text-align-last: justify;    -webkit-text-align-last: justify;}</code></pre><p><strong>5.现文字竖向排版</strong></p><pre><code>// 单列展示时.wrap {    width: 25px;    line-height: 18px;    height: auto;    font-size: 12px;    padding: 8px 5px;    word-wrap: break-word;/*英文的时候需要加上这句，自动换行*/  }// 多列展示时.wrap {    height: 210px;    line-height: 30px;    text-align: justify;    writing-mode: vertical-lr;  //从左向右        writing-mode: tb-lr;        //IE从左向右    //writing-mode: vertical-rl;  -- 从右向左    //writing-mode: tb-rl;        -- 从右向左}</code></pre><p><strong>6.使元素鼠标事件失效</strong></p><pre><code>.wrap {    // 如果按tab能选中该元素，如button，然后按回车还是能执行对应的事件，如click。  pointer-events: none;    cursor: default;}</code></pre><p><strong>7.禁止用户选择</strong></p><pre><code>.wrap {  -webkit-touch-callout: none;  -webkit-user-select: none;  -khtml-user-select: none;  -moz-user-select: none;  -ms-user-select: none;  user-select: none;}</code></pre><p><strong>8.cursor属性</strong></p><pre><code>.wrap {  cursor：pointer; //小手指；  cursor：help; //箭头加问号；  cursor：wait; //转圈圈；  cursor：move; //移动光标；  cursor：crosshair; //十字光标}</code></pre><p><strong>9.使用硬件加速</strong></p><pre><code>.wrap {    transform: translateZ(0);}</code></pre><p><strong>10.图片宽度自适应</strong></p><pre><code>img {max-width: 100%}</code></pre><p><strong>11.Text-transform和Font Variant</strong></p><pre><code>p {text-transform: uppercase}  // 将所有字母变成大写字母p {text-transform: lowercase}  // 将所有字母变成小写字母p {text-transform: capitalize} // 首字母大写p {font-variant: small-caps}   // 将字体变成小型的大写字母</code></pre><p><strong>12.将一个容器设为透明</strong></p><pre><code>.wrap {   filter:alpha(opacity=50);   -moz-opacity:0.5;   -khtml-opacity: 0.5;   opacity: 0.5; }</code></pre><p><strong>13.消除transition闪屏</strong></p><pre><code>.wrap {    -webkit-transform-style: preserve-3d;    -webkit-backface-visibility: hidden;    -webkit-perspective: 1000;}</code></pre><p><strong>14.自定义滚动条</strong></p><pre><code>overflow-y: scroll;整个滚动条::-webkit-scrollbar {    width: 5px;}滚动条的轨道::-webkit-scrollbar-track {    background-color: #ffa336;    border-radius: 5px;}滚动条的滑块::-webkit-scorllbar-thumb {    background-color: #ffc076;    border-radius: 5px;}</code></pre><p><strong>15让 HTML 识别 string 里的 ‘\n’ 并换行</strong></p><pre><code>body {    white-space: pre-line;}</code></pre><p><strong>16.实现一个三角形</strong></p><pre><code>.wrap {   border-color: transparent transparent green transparent;   border-style: solid;   border-width: 0px 300px 300px 300px;   height: 0px;   width: 0px; }</code></pre><p><strong>17.移除被点链接的边框</strong></p><pre><code>  a {outline: none}  a {outline: 0}</code></pre><p><strong>18.使用CSS显示链接之后的URL</strong></p><pre><code>a:after{content:&quot; (&quot; attr(href) &quot;) &quot;;}</code></pre><p><strong>19.select内容居中显示、下拉内容右对齐</strong></p><pre><code>  select{      text-align: center;      text-align-last: center;  }  select option {      direction: rtl;  }</code></pre><p><strong>20.修改input输入框中光标的颜色不改变字体的颜色</strong></p><pre><code>  input{      color:  #fff;      caret-color: red;  }</code></pre><p><strong>21.修改input 输入框中 placeholder 默认字体样式</strong></p><pre><code>  //webkit内核的浏览器   input::-webkit-input-placeholder {      color: #c2c6ce;  }  //Firefox版本4-18   input:-moz-placeholder {      color: #c2c6ce;  }  //Firefox版本19+  input::-moz-placeholder {      color: #c2c6ce;  }  //IE浏览器  input:-ms-input-placeholder {      color: #c2c6ce;  }</code></pre><p><strong>22.子元素固定宽度 父元素宽度被撑开</strong></p><pre><code>// 父元素下的子元素是行内元素.wrap {  white-space: nowrap;}// 若父元素下的子元素是块级元素.wrap {  white-space: nowrap;  // 子元素不被换行  display: inline-block;}</code></pre><p><strong>23.让div里的图片和文字同时上下居中</strong></p><pre><code>  .wrap {    height: 100,    line-height: 100  }  img {    vertival-align：middle  }</code></pre><p>// vertical-align css的属性vertical-align用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。只对行内元素、表格单元格元素生效，不能用它垂直对齐块级元素<br>// vertical-align：baseline/top/middle/bottom/sub/text-top;</p><p><strong>24.实现宽高等比例自适应矩形</strong></p><pre><code>    .scale {        width: 100%;        padding-bottom: 56.25%;        height: 0;        position: relative;     }    .item {        position: absolute;         width: 100%;        height: 100%;        background-color: 499e56;    }    </code></pre>   <div class="scale">        <div class="item">            这里是所有子元素的容器        </div>    </div><p><strong>25.transfrom的rotate属性在span标签下失效</strong></p><pre><code>  span {    display: inline-block  }</code></pre><p><strong>26.边框字体同色</strong></p><pre><code>.wrap {    width: 200px;    height: 200px;    color: #000;    font-size: 30px;    border: 50px solid currentColor;    // border: 50px solid; // 实现二}</code></pre><p>  <strong>27.实现一个多边形</strong><br>     clip-path: polygon()</p>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>也谈面试必备问题之 JavaScript 数组去重</title>
      <link href="/2019/09/22/javascript-shu-zu-qu-chong/"/>
      <url>/2019/09/22/javascript-shu-zu-qu-chong/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28854182&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><hr><p>数组去重</p><p><strong>方法一</strong><br>无需思考，我们可以得到 O(n^2) 复杂度的解法。定义一个变量数组 res 保存结果，遍历需要去重的数组，如果该元素已经存在在 res 中了，则说明是重复的元素，如果没有，则放入 res 中。</p><pre><code>  function unique(a) {  var res = [];  for (var i = 0, len = a.length; i &lt; len; i++) {  var item = a[i];      for (var j = 0, jLen = res.length; j &lt; jLen; j++) {        if (res[j] === item)          break;      }      if (j === jLen)        res.push(item);  }  return res;  }  var a = [1, 1, &#39;1&#39;, &#39;2&#39;, 1];  var ans = unique(a);  console.log(ans); // =&gt; [1, &quot;1&quot;, &quot;2&quot;]</code></pre><p>代码非常简单，那么是否能更简洁些？如果不考虑浏览器兼容，我们可以用 ES5 提供的 Array.prototype.indexOf 方法来简化代码。</p><pre><code>  function unique(a) {  var res = [];  for (var i = 0, len = a.length; i &lt; len; i++) {  var item = a[i];      (res.indexOf(item) === -1) &amp;&amp; res.push(item);  }  return res;  }  var a = [1, 1, &#39;1&#39;, &#39;2&#39;, 1];  var ans = unique(a);  console.log(ans); // =&gt; [1, &quot;1&quot;, &quot;2&quot;]  既然用了 indexOf，那么不妨再加上 filter。  function unique(a) {  var res = a.filter(function(item, index, array) {  return array.indexOf(item) === index;  });  return res;  }  var a = [1, 1, &#39;1&#39;, &#39;2&#39;, 1];  var ans = unique(a);  console.log(ans); // =&gt; [1, &quot;1&quot;, &quot;2&quot;]</code></pre><p><strong>方法二</strong><br>法一是将原数组中的元素和结果数组中的元素一一比较，我们可以换个思路，将原数组中重复元素的最后一个元素放入结果数组中。</p><pre><code>  function unique(a) {  var res = [];  for (var i = 0, len = a.length; i &lt; len; i++) {  for (var j = i + 1; j &lt; len; j++) {  // 这一步十分巧妙  // 如果发现相同元素  // 则 i 自增进入下一个循环比较  if (a[i] === a[j])  j = ++i;  }      res.push(a[i]);  }  return res;  }  var a = [1, 1, &#39;1&#39;, &#39;2&#39;, 1];  var ans = unique(a);  console.log(ans); // =&gt; [&quot;1&quot;, &quot;2&quot;, 1]</code></pre><p>虽然复杂度还是 O(n^2)，但是可以看到结果不同，1 出现在了数组最后面，因为结果数组取的是元素最后一次出现的位置。</p><p><strong>方法三（sort)</strong><br>如果笔试面试时只答出了上面这样 O(n^2) 的方案，可能还不能使面试官满意，下面就来说几种进阶方案。</p><p>将数组用 sort 排序后，理论上相同的元素会被放在相邻的位置，那么比较前后位置的元素就可以了。</p><pre><code>  function unique(a) {  return a.concat().sort().filter(function(item, pos, ary) {  return !pos || item != ary[pos - 1];  });  }  var a = [1, 1, 3, 2, 1, 2, 4];  var ans = unique(a);  console.log(ans); // =&gt; [1, 2, 3, 4]</code></pre><p>但是问题又来了，1 和 “1” 会被排在一起，不同的 Object 会被排在一起，因为它们 toString() 的结果相同，所以会出现这样的错误：</p><pre><code>  var a = [1, 1, 3, 2, 1, 2, 4, &#39;1&#39;];  var ans = unique(a);  console.log(ans); // =&gt; [1, 2, 3, 4]</code></pre><p>当然你完全可以针对数组中可能出现的不同类型，来写这个比较函数。不过这似乎有点麻烦。</p><p><strong>方法四 （object）</strong><br>用 JavaScript 中的 Object 对象来当做哈希表，这也是几年前笔试时的解法，跟 sort 一样，可以去重完全由 Number 基本类型组成的数组。</p><pre><code>  function unique(a) {  var seen = {};  return a.filter(function(item) {  return seen.hasOwnProperty(item) ? false : (seen[item] = true);  });  }  var a = [1, 1, 3, 2, 1, 2, 4];  var ans = unique(a);  console.log(ans); // =&gt; [1, 3, 2, 4]</code></pre><p>还是和方法三一样的问题，因为 Object 的 key 值都是 String 类型，所以对于 1 和 “1” 无法分别，我们可以稍微改进下，将类型也存入 key 中。</p><pre><code>  function unique(a) {  var ret = [];  var hash = {};  for (var i = 0, len = a.length; i &lt; len; i++) {  var item = a[i];      var key = typeof(item) + item;      if (hash[key] !== 1) {        ret.push(item);        hash[key] = 1;      }  }  return ret;  }  var a = [1, 1, 3, 2, &#39;4&#39;, 1, 2, 4, &#39;1&#39;];  var ans = unique(a);  console.log(ans); // =&gt; [1, 3, 2, &quot;4&quot;, 4, &quot;1&quot;]</code></pre><p>虽然解决了讨厌的 1 和 “1” 的问题，但是还有别的问题！</p><pre><code>  var a = [{name: &quot;hanzichi&quot;}, {age: 30}, new String(1), new Number(1)];  var ans = unique(a);  console.log(ans); // =&gt; [Object, String]</code></pre><p>但是如果数组元素全部是基础类型的 Number 值，键值对法应该是最高效的！</p><p><strong>方法五 （ES6）</strong><br>ES6 部署了 Set 以及 Array.from 方法，太强大了！如果浏览器支持，完全可以这样：</p><pre><code>  function unique(a) {  return Array.from(new Set(a));  }  var a = [{name: &quot;hanzichi&quot;}, {age: 30}, new String(1), new Number(1)];  var ans = unique(a);  console.log(ans); // =&gt; [Object, Object, String, Number]  _.unique</code></pre><p>最后来看看 underscore 对此的实现方式，underscore 将此封装到了 <em>.unique 方法中，调用方式为 \</em>.unique(array, [isSorted], [iteratee])。其中第一个参数是必须的，是需要去重的数组，第二个参数可选，如果数组有序，则可以传入布尔值 true，第三个参数可选，如果需要对数组迭代的结果去重，则可以传入一个迭代函数。而数组元素去重是基于 === 运算符的。</p><p>其实很简单，underscore 中的实现方式和上面的方法一相似。</p><p>我们来看它的核心代码：</p><pre><code>  for (var i = 0, length = getLength(array); i &lt; length; i++) {  var value = array[i],  // 如果指定了迭代函数  // 则对数组每一个元素进行迭代  computed = iteratee ? iteratee(value, i, array) : value;  // 如果是有序数组，则当前元素只需跟上一个元素对比即可  // 用 seen 变量保存上一个元素  if (isSorted) {  // 如果 i === 0，则直接 push  // 否则比较当前元素是否和前一个元素相等  if (!i || seen !== computed) result.push(value);  // seen 保存当前元素，供下一次对比  seen = computed;  } else if (iteratee) {  // 如果 seen[] 中没有 computed 这个元素值  if (!_.contains(seen, computed)) {  seen.push(computed);  result.push(value);  }  } else if (!_.contains(result, value)) {    // 如果不用经过迭代函数计算，也就不用 seen[] 变量了  result.push(value);  }  }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0搭建自己的webpack开发环境(转)</title>
      <link href="/2019/09/22/cong-0-da-jian-zi-ji-de-webpack-kai-fa-huan-jing/"/>
      <url>/2019/09/22/cong-0-da-jian-zi-ji-de-webpack-kai-fa-huan-jing/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=411214279&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="从0搭建自己的webpack开发环境"><a href="#从0搭建自己的webpack开发环境" class="headerlink" title="从0搭建自己的webpack开发环境"></a><a href="https://juejin.im/post/5d7f4f14518825491b7240b7" target="_blank" rel="noopener">从0搭建自己的webpack开发环境</a></h1><hr><h1 id="webpack问题"><a href="#webpack问题" class="headerlink" title="webpack问题"></a>webpack问题</h1><ul><li><p><a href="https://www.webpackjs.com/" target="_blank" rel="noopener">webpack官网</a></p></li><li><p><a href="https://juejin.im/post/5db01b366fb9a0202f0c89bb" target="_blank" rel="noopener">webpack多页面内存溢出</a></p></li><li><p><a href="https://juejin.im/post/5aa3d2056fb9a028c36868aa" target="_blank" rel="noopener">webpack详解</a></p></li><li><p><a href="https://juejin.im/post/59bb37fa6fb9a00a554f89d2" target="_blank" rel="noopener">webpack：从入门到真实项目配置</a></p></li><li><p><a href="https://juejin.im/entry/5794d711128fe10056b947fe/detail" target="_blank" rel="noopener">Vue+Webpack 使用规范</a></p></li><li><p><a href="https://juejin.im/post/5bf61082f265da616a474b5c" target="_blank" rel="noopener">脑阔疼的webpack按需加载</a></p></li><li><p><a href="https://juejin.im/post/5b9116086fb9a05d05307e96" target="_blank" rel="noopener">webpack4 多页面，多环境配置</a></p></li><li><p><a href="https://juejin.im/entry/57cd199467f3560057c99607" target="_blank" rel="noopener">webpack 性能优化</a></p></li><li><p><a href="https://juejin.im/post/5af3be6d6fb9a07ab458a393" target="_blank" rel="noopener">如何让webpack打包的速度提升50%？</a></p></li><li><p><a href="https://www.cnblogs.com/sichaoyun/p/9241829.html" target="_blank" rel="noopener">vue-cli脚手架中webpack配置基础文件详解</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个基于vue和element-ui的树形穿梭框组件</title>
      <link href="/2019/08/20/vue-element-chuan-suo-kuang/"/>
      <url>/2019/08/20/vue-element-chuan-suo-kuang/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28854182&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><hr><p>一个基于vue和element-ui的树形穿梭框组件</p><p><strong>el-tree-transfer</strong></p><blockquote><p>el-tree-fransfer是一个基于VUE和element-ui的树形穿梭框组件，使用前请确认已经引入element-ui！ 此组件功能类似于element-ui的transfer组件，但是里面的数据是树形结构！ 实际上，el-tree-transfer依赖的element-ui组件分别是Checkbox 多选框，Button 按钮，和最主要的Tree 树形控件写成！并非是在element-ui的穿梭框组件上的扩展，而仅仅是参照了其外观样式和功能。ui完全按照element-ui风格。<br>注意：使用此插件时默认你已经引入了element-ui的button，check-box，tree组件！<br>第一层数据的 pid 请设定为 0！！<br>id推荐为string，但也可以是number，请不要混用，id不能重复！</p></blockquote><p><strong>1.先npm下载插件</strong><br>     1. npm install el-tree-transfer –save<br>      或<br>     2.npm i el-tree-transfer -S</p><p>然后你可以像使用普通组件一样使用el-tree-transfer</p><pre><code>  &lt;template&gt;      &lt;div&gt;      // 你的代码      ...      // 使用树形穿梭框组件      &lt;tree-transfer :title=&quot;title&quot; :from_data=&#39;fromData&#39; :to_data=&#39;toData&#39; :defaultProps=&quot;{label:&#39;label&#39;}&quot;             @addBtn=&#39;add&#39; @removeBtn=&#39;remove&#39; :mode=&#39;mode&#39; height=&#39;540px&#39; filter openAll&gt;      &lt;/tree-transfer&gt;    &lt;/div&gt;  &lt;/template&gt;    &lt;script&gt;  import treeTransfer from &#39;el-tree-transfer&#39; // 引入    export defult {      data(){        return:{          mode: &quot;transfer&quot;, // transfer addressList          fromData:[            {              id: &quot;1&quot;,              pid: 0,              label: &quot;一级 1&quot;,              children: [                {                  id: &quot;1-1&quot;,                  pid: &quot;1&quot;,                  label: &quot;二级 1-1&quot;,                  children: []                },                {                  id: &quot;1-2&quot;,                  pid: &quot;1&quot;,                  label: &quot;二级 1-2&quot;,                  children: [                    {                      id: &quot;1-2-1&quot;,                      pid: &quot;1-2&quot;,                      children: [],                      label: &quot;二级 1-2-1&quot;                    },                    {                      id: &quot;1-2-2&quot;,                      pid: &quot;1-2&quot;,                      children: [],                      label: &quot;二级 1-2-2&quot;                    }                  ]                }              ]            },          ],          toData:[]        }      },      methods:{        // 切换模式 现有树形穿梭框模式transfer 和通讯录模式addressList        changeMode() {          if (this.mode == &quot;transfer&quot;) {            this.mode = &quot;addressList&quot;;          } else {            this.mode = &quot;transfer&quot;;          }        },        // 监听穿梭框组件添加        add(fromData,toData,obj){          // 树形穿梭框模式transfer时，返回参数为左侧树移动后数据、右侧树移动后数据、移动的        {keys,nodes,halfKeys,halfNodes}对象          // 通讯录模式addressList时，返回参数为右侧收件人列表、右侧抄送人列表、右侧密送人列表          console.log(&quot;fromData:&quot;, fromData);          console.log(&quot;toData:&quot;, toData);          console.log(&quot;obj:&quot;, obj);        },        // 监听穿梭框组件移除        remove(fromData,toData,obj){          // 树形穿梭框模式transfer时，返回参数为左侧树移动后数据、右侧树移动后数据、移动的{keys,nodes,halfKeys,halfNodes}对象          // 通讯录模式addressList时，返回参数为右侧收件人列表、右侧抄送人列表、右侧密送人列表          console.log(&quot;fromData:&quot;, fromData);          console.log(&quot;toData:&quot;, toData);          console.log(&quot;obj:&quot;, obj);        }      },      comporents:{ treeTransfer } // 注册    }  &lt;/script&gt;  &lt;style&gt;  ...  &lt;/style&gt;</code></pre><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><hr><p>参数：width 说明：宽度 类型：String 必填：false 默认：100% 补充：建议在外部盒子设定宽度和位置<br>参数：height 说明：高度 类型：String 必填：false 默认：320px<br>参数：title 说明：标题 类型：Array 必填：false 默认：[“源列表”, “目标列表”]<br>参数：button_text 说明：按钮名字 类型：Array 必填：false 默认：空<br>参数：from_data 说明：源数据 类型：Array 必填：true 补充：数据格式同element-ui tree组件，但必须有id和pid<br>参数：to_data 说明：目标数据 类型：Array 必填：true 补充：数据格式同element-ui tree组件，但必须有id和pid<br>参数：defaultProps 说明：配置项-同el-tree中props 必填： false 补充：用法和el-tree的props一样<br>参数：node_key 说明：自定义node-key的值，默认为id 必填：false 补充：必须与treedata数据内的id参数名一致，必须唯一<br>参数：pid 说明：自定义pid的参数名，默认为”pid” 必填：false 补充：有网友提出后台给的字段名不叫pid，因此增加自定义支持<br>参数：leafOnly 说明：是否只返回叶子节点 类型：Boolean 必填：false 补充：默认false，如果你只需要返回的末端子节点可使用此参数<br>参数：filter 说明：是否开启筛选功能 类型：Boolean 必填：false<br>参数：openAll 说明：是否默认展开全部 类型：Boolean 必填：false<br>参数：renderContent 说明：自定义树节点 类型：Function 必填：false 补充：用法同element-ui tree<br>参数：mode 说明：设置模式，字段可选值为transfer|addressList 类型：String 必填：false 补充：mode默认为transfer模式，即树形穿梭框模式，可配置字段为addressList改为通讯录模式，通讯录模式时按钮不可自定义名字，如要自定义标题名在title数组传入四个值即可，addressList模式时标题默认为通讯录、收件人、抄送人、密送人<br>参数：transferOpenNode 说明：穿梭后是否展开穿梭的节点 类型：Boolean 必填：false 补充：默认为true即展开穿梭的节点，便于视觉查看，增加此参数是因为数据量大时展开会有明显卡顿问题，但注意，如此参数设置为false则穿梭后不展开，毕竟无法确定第几层就会有庞大数据<br>参数：defaultCheckedKeys 说明：默认展开节点 类型：Array 必填：false 补充：只匹配初始时默认节点，不会在你操作后动态改变默认节点<br>参数：placeholder 说明：设置搜索框提示语 类型：String 必填：false 补充：默认为请输入关键词进行筛选<br>参数：defaultTransfer 说明：是否自动穿梭一次默认选中defaultCheckedKeys的节点 类型：Boolean 必填：false 补充：默认false，用来满足用户不想将数据拆分成fromData和toData的需求<br>参数：arrayToTree 说明：是否开启一维数组转化为树形结构 类型：Boolean 必填：false 补充：数据必须存在根节点，并且不会断节，数据格式详见github上app.vue，根据id、pid对应关系转化，存在一定的性能问题<br>参数：addressOptions 说明：通讯录模式配置项{num: Number, suffix: String, connector: String} 类型：Object 必填：false 补充：num-&gt; 所需右侧通讯录个数,默认3 suffix-&gt; label后想要拼接的字段（如id，即取此条数据的id拼接在后方）默认suffix connector -&gt; 连接符（字符串）默认-<br>参数：lazy 说明：是否启用懒加载 类型：Boolean 必填：false 补充：默认false，效果动el-tree懒加载，不可和openAll或默认展开同时使用<br>参数：lazyFn 说明：懒加载的回调函数 类型：Function 必填：true 补充：当适用lazy时必须传入回调函数，示例:lazyFn=’loadNode’,返回参数loadNode(node, resolve, from), node-&gt;当前展开节点node，resolve-&gt;懒加载resolve，from -&gt; left|right 表示回调来自左侧|右侧<br>事件：addBtn 说明：点击添加按钮时触发的事件 回调参数：function(fromData,toData,obj),树形穿梭框transfer模式分别为1.移动后左侧数据，2.移动后右侧数据，3.移动的节点keys、nodes、halfKeys、halfNodes对象；通讯录addressList模式时返回参数为右侧收件人列表、右侧抄送人列表、右侧密送人列表<br>事件：removeBtn 说明：点击移除按钮时触发的事件 回调参数：function(fromData,toData,obj),树形穿梭框transfer模式分别为1.移动后左侧数据，2.移动后右侧数据，3.移动的节点keys、nodes、halfKeys、halfNodes对象；通讯录addressList模式时返回参数为右侧收件人列表、右侧抄送人列表、右侧密送人列表<br>事件：left-check-change 说明：左侧源数据勾选事件 回调参数：function(nodeObj, treeObj)见el-tree组件check事件返回值<br>事件：right-check-change 说明：右侧目标数据勾选事件 回调参数：function(nodeObj, treeObj)见el-tree组件check事件返回值<br>Slot：left-footer, right-footer 说明：穿梭框左侧、右侧底部slot<br>Slot: title-left, title-right 说明：穿梭框标题区左侧、右侧自定义内容</p>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Echars中常用方法</title>
      <link href="/2019/07/22/echars-zhong-chang-yong-fang-fa/"/>
      <url>/2019/07/22/echars-zhong-chang-yong-fang-fa/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=411214279&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="Echars中常用方法"><a href="#Echars中常用方法" class="headerlink" title="Echars中常用方法"></a>Echars中常用方法</h1><hr><p><strong>1.什么是Echars?</strong></p><blockquote><p>一个纯JavaScript图表库。<a href="https://www.echartsjs.com/zh/index.html" target="_blank" rel="noopener">ECharts官网</a>，缩写来自Enterprise Charts，商业级数据图表，一个纯Javascript的图表库，可以流畅的运行在PC和移动设备上，兼容当前绝大部分浏览器（IE6/7/8/9/10/11，chrome，firefox，Safari等），底层依赖轻量级的Canvas类库ZRender，提供直观，生动，可交互，可高度个性化定制的数据可视化图表。创新的拖拽重计算、数据视图、值域漫游等特性大大增强了用户体验，赋予了用户对数据进行挖掘、整合的能力。</p></blockquote><h2 id="1-Echars术语速查手册-gt"><a href="#1-Echars术语速查手册-gt" class="headerlink" title="1. Echars术语速查手册 -&gt;"></a>1. Echars术语速查手册 -&gt;</h2><ul><li><a href="https://www.echartsjs.com/zh/cheat-sheet.html" target="_blank" rel="noopener">Echars术语速查手册</a></li></ul><h2 id="2-echarts属性的设置（完整大全）"><a href="#2-echarts属性的设置（完整大全）" class="headerlink" title="2. echarts属性的设置（完整大全）"></a>2. echarts属性的设置（完整大全）</h2><h3 id="全图默认背景"><a href="#全图默认背景" class="headerlink" title="全图默认背景"></a>全图默认背景</h3><pre><code>  // backgroundColor: ‘rgba(0,0,0,0)’,  // 默认色板  color: [&#39;#ff7f50&#39;,&#39;#87cefa&#39;,&#39;#da70d6&#39;,&#39;#32cd32&#39;,&#39;#6495ed&#39;,      &#39;#ff69b4&#39;,&#39;#ba55d3&#39;,&#39;#cd5c5c&#39;,&#39;#ffa500&#39;,&#39;#40e0d0&#39;,      &#39;#1e90ff&#39;,&#39;#ff6347&#39;,&#39;#7b68ee&#39;,&#39;#00fa9a&#39;,&#39;#ffd700&#39;,      &#39;#6699FF&#39;,&#39;#ff6666&#39;,&#39;#3cb371&#39;,&#39;#b8860b&#39;,&#39;#30e0e0&#39;],</code></pre><h3 id="1-图表标题"><a href="#1-图表标题" class="headerlink" title="1.图表标题"></a>1.图表标题</h3><pre><code>  title: {      x: &#39;left&#39;,                // 水平安放位置，默认为左对齐，可选为：                        // &#39;center&#39; ¦ &#39;left&#39; ¦ &#39;right&#39;                        // ¦ {number}（x坐标，单位px）      y: &#39;top&#39;,             // 垂直安放位置，默认为全图顶端，可选为：                        // &#39;top&#39; ¦ &#39;bottom&#39; ¦ &#39;center&#39;                        // ¦ {number}（y坐标，单位px）      //textAlign: null          // 水平对齐方式，默认根据x设置自动调整      backgroundColor: &#39;rgba(0,0,0,0)&#39;,      borderColor: &#39;#ccc&#39;,          // 标题边框颜色      borderWidth: 0,           // 标题边框线宽，单位px，默认为0（无边框）      padding: 5,             // 标题内边距，单位px，默认各方向内边距为5，                                // 接受数组分别设定上右下左边距，同css      itemGap: 10,             // 主副标题纵向间隔，单位px，默认为10，      textStyle: {          fontSize: 18,          fontWeight: &#39;bolder&#39;,          color: &#39;#333&#39;                             // 主标题文字颜色      },      subtextStyle: {          color: &#39;#aaa&#39;                            // 副标题文字颜色      }  },</code></pre><h3 id="2-图例"><a href="#2-图例" class="headerlink" title="2.图例"></a>2.图例</h3><pre><code>  legend: {      orient: &#39;horizontal&#39;,          // 布局方式，默认为水平布局，可选为：                        // &#39;horizontal&#39; ¦ &#39;vertical&#39;      x: &#39;center&#39;,                // 水平安放位置，默认为全图居中，可选为：                                // &#39;center&#39; ¦ &#39;left&#39; ¦ &#39;right&#39;                        // ¦ {number}（x坐标，单位px）      y: &#39;top&#39;,              // 垂直安放位置，默认为全图顶端，可选为：                        // &#39;top&#39; ¦ &#39;bottom&#39; ¦ &#39;center&#39;                        // ¦ {number}（y坐标，单位px）      backgroundColor: &#39;rgba(0,0,0,0)&#39;,      borderColor: &#39;#ccc&#39;,            // 图例边框颜色      borderWidth: 0,                // 图例边框线宽，单位px，默认为0（无边框）      padding: 5,                  // 图例内边距，单位px，默认各方向内边距为5，                                // 接受数组分别设定上右下左边距，同css      itemGap: 10,              // 各个item之间的间隔，单位px，默认为10，                          // 横向布局时为水平间隔，纵向布局时为纵向间隔      itemWidth: 20,             // 图例图形宽度      itemHeight: 14,            // 图例图形高度      textStyle: {          color: &#39;#333&#39;                              // 图例文字颜色      }  },</code></pre><h3 id="3-值域"><a href="#3-值域" class="headerlink" title="3.值域"></a>3.值域</h3><pre><code>  dataRange: {      orient: &#39;vertical&#39;,             // 布局方式，默认为垂直布局，可选为：                          // &#39;horizontal&#39; ¦ &#39;vertical&#39;      x: &#39;left&#39;,                   // 水平安放位置，默认为全图左对齐，可选为：                          // &#39;center&#39; ¦ &#39;left&#39; ¦ &#39;right&#39;                          // ¦ {number}（x坐标，单位px）      y: &#39;bottom&#39;,                  // 垂直安放位置，默认为全图底部，可选为：                          // &#39;top&#39; ¦ &#39;bottom&#39; ¦ &#39;center&#39;                          // ¦ {number}（y坐标，单位px）      backgroundColor: &#39;rgba(0,0,0,0)&#39;,      borderColor: &#39;#ccc&#39;,             // 值域边框颜色      borderWidth: 0,                 // 值域边框线宽，单位px，默认为0（无边框）      padding: 5,                    // 值域内边距，单位px，默认各方向内边距为5，                          // 接受数组分别设定上右下左边距，同css      itemGap: 10,               // 各个item之间的间隔，单位px，默认为10，                          // 横向布局时为水平间隔，纵向布局时为纵向间隔      itemWidth: 20,             // 值域图形宽度，线性渐变水平布局宽度为该值 * 10      itemHeight: 14,            // 值域图形高度，线性渐变垂直布局高度为该值 * 10      splitNumber: 5,            // 分割段数，默认为5，为0时为线性渐变      color:[&#39;#1e90ff&#39;,&#39;#f0ffff&#39;],//颜色      //text:[&#39;高&#39;,&#39;低&#39;],              // 文本，默认为数值文本      textStyle: {          color: &#39;#333&#39;                                // 值域文字颜色      }  },  toolbox: {      orient: &#39;horizontal&#39;,            // 布局方式，默认为水平布局，可选为：                          // &#39;horizontal&#39; ¦ &#39;vertical&#39;      x: &#39;right&#39;,              // 水平安放位置，默认为全图右对齐，可选为：                          // &#39;center&#39; ¦ &#39;left&#39; ¦ &#39;right&#39;                          // ¦ {number}（x坐标，单位px）      y: &#39;top&#39;,               // 垂直安放位置，默认为全图顶端，可选为：                          // &#39;top&#39; ¦ &#39;bottom&#39; ¦ &#39;center&#39;                          // ¦ {number}（y坐标，单位px）      color : [&#39;#1e90ff&#39;,&#39;#22bb22&#39;,&#39;#4b0082&#39;,&#39;#d2691e&#39;],      backgroundColor: &#39;rgba(0,0,0,0)&#39;,    // 工具箱背景颜色      borderColor: &#39;#ccc&#39;,             // 工具箱边框颜色      borderWidth: 0,                 // 工具箱边框线宽，单位px，默认为0（无边框）      padding: 5,                    // 工具箱内边距，单位px，默认各方向内边距为5，                                  // 接受数组分别设定上右下左边距，同css      itemGap: 10,                  // 各个item之间的间隔，单位px，默认为10，                                  // 横向布局时为水平间隔，纵向布局时为纵向间隔      itemSize: 16,              // 工具箱图形宽度      featureImageIcon : {},            // 自定义图片icon      featureTitle : {          mark : &#39;辅助线开关&#39;,          markUndo : &#39;删除辅助线&#39;,          markClear : &#39;清空辅助线&#39;,          dataZoom : &#39;区域缩放&#39;,          dataZoomReset : &#39;区域缩放后退&#39;,          dataView : &#39;数据视图&#39;,          lineChart : &#39;折线图切换&#39;,          barChart : &#39;柱形图切换&#39;,          restore : &#39;还原&#39;,          saveAsImage : &#39;保存为图片&#39;      }  },</code></pre><h3 id="4-提示框"><a href="#4-提示框" class="headerlink" title="4.提示框"></a>4.提示框</h3><pre><code>  tooltip: {      trigger: &#39;item&#39;,           // 触发类型，默认数据触发，见下图，可选为：&#39;item&#39; ¦ &#39;axis&#39;      showDelay: 20,             // 显示延迟，添加显示延迟可以避免频繁切换，单位ms      hideDelay: 100,            // 隐藏延迟，单位ms      transitionDuration : 0.4,         // 动画变换时间，单位s      backgroundColor: &#39;rgba(0,0,0,0.7)&#39;,  // 提示背景颜色，默认为透明度为0.7的黑色      borderColor: &#39;#333&#39;,            // 提示边框颜色      borderRadius: 4,                // 提示边框圆角，单位px，默认为4      borderWidth: 0,                // 提示边框线宽，单位px，默认为0（无边框）      padding: 5,                   // 提示内边距，单位px，默认各方向内边距为5，                                  // 接受数组分别设定上右下左边距，同css      axisPointer : {                 // 坐标轴指示器，坐标轴触发有效          type : &#39;line&#39;,         // 默认为直线，可选为：&#39;line&#39; | &#39;shadow&#39;          lineStyle : {          // 直线指示器样式设置              color: &#39;#48b&#39;,              width: 2,              type: &#39;solid&#39;          },          shadowStyle : {              // 阴影指示器样式设置              width: &#39;auto&#39;,         // 阴影大小              color: &#39;rgba(150,150,150,0.3)&#39;  // 阴影颜色          }      },      textStyle: {          color: &#39;#fff&#39;      }  },</code></pre><h3 id="5-区域缩放控制器"><a href="#5-区域缩放控制器" class="headerlink" title="5.区域缩放控制器"></a>5.区域缩放控制器</h3><pre><code>  dataZoom: {      orient: &#39;horizontal&#39;,         // 布局方式，默认为水平布局，可选为：                              // &#39;horizontal&#39; ¦ &#39;vertical&#39;      // x: {number},              // 水平安放位置，默认为根据grid参数适配，可选为：                              // {number}（x坐标，单位px）      // y: {number},              // 垂直安放位置，默认为根据grid参数适配，可选为：                              // {number}（y坐标，单位px）      // width: {number},           // 指定宽度，横向布局时默认为根据grid参数适配      // height: {number},          // 指定高度，纵向布局时默认为根据grid参数适配      backgroundColor: &#39;rgba(0,0,0,0)&#39;,    // 背景颜色      dataBackgroundColor: &#39;#eee&#39;,       // 数据背景颜色      fillerColor: &#39;rgba(144,197,237,0.2)&#39;, // 填充颜色      handleColor: &#39;rgba(70,130,180,0.8)&#39;       // 手柄颜色  },</code></pre><h3 id="6-网格"><a href="#6-网格" class="headerlink" title="6.网格"></a>6.网格</h3><pre><code>  grid: {      x: 80,      y: 60,      x2: 80,      y2: 60,      // width: {totalWidth} - x - x2,      // height: {totalHeight} - y - y2,      backgroundColor: &#39;rgba(0,0,0,0)&#39;,      borderWidth: 1,      borderColor: &#39;#ccc&#39;  },</code></pre><h3 id="7-类目轴"><a href="#7-类目轴" class="headerlink" title="7.类目轴"></a>7.类目轴</h3><pre><code>  categoryAxis: {      position: &#39;bottom&#39;,        // 位置      nameLocation: &#39;end&#39;,      // 坐标轴名字位置，支持&#39;start&#39; | &#39;end&#39;      boundaryGap: true,     // 类目起始和结束两端空白策略      axisLine: {            // 坐标轴线          show: true,         // 默认显示，属性show控制显示与否          lineStyle: {        // 属性lineStyle控制线条样式              color: &#39;#48b&#39;,              width: 2,              type: &#39;solid&#39;          }      },      axisTick: {            // 坐标轴小标记          show: true,       // 属性show控制显示与否，默认不显示          interval: &#39;auto&#39;,          // onGap: null,          inside : false,        // 控制小标记是否在grid里          length :5,         // 属性length控制线长          lineStyle: {       // 属性lineStyle控制线条样式              color: &#39;#333&#39;,              width: 1          }      },      axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel          show: true,          interval: &#39;auto&#39;,          rotate: 0,          margin: 8,          // formatter: null,          textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE              color: &#39;#333&#39;          }      },      splitLine: {                // 分隔线          show: true,        // 默认显示，属性show控制显示与否          // onGap: null,          lineStyle: {       // 属性lineStyle（详见lineStyle）控制线条样式              color: [&#39;#ccc&#39;],              width: 1,              type: &#39;solid&#39;          }      },      splitArea: {                // 分隔区域          show: false,       // 默认不显示，属性show控制显示与否          // onGap: null,          areaStyle: {        // 属性areaStyle（详见areaStyle）控制区域样式              color: [&#39;rgba(250,250,250,0.3)&#39;,&#39;rgba(200,200,200,0.3)&#39;]          }      }  },</code></pre><h3 id="8-数值型坐标轴默认参数"><a href="#8-数值型坐标轴默认参数" class="headerlink" title="8.数值型坐标轴默认参数"></a>8.数值型坐标轴默认参数</h3><pre><code>  valueAxis: {      position: &#39;left&#39;,      // 位置      nameLocation: &#39;end&#39;,     // 坐标轴名字位置，支持&#39;start&#39; | &#39;end&#39;      nameTextStyle: {},     // 坐标轴文字样式，默认取全局样式      boundaryGap: [0, 0],    // 数值起始和结束两端空白策略      splitNumber: 5,        // 分割段数，默认为5      axisLine: {             // 坐标轴线          show: true,      // 默认显示，属性show控制显示与否          lineStyle: {      // 属性lineStyle控制线条样式              color: &#39;#48b&#39;,              width: 2,              type: &#39;solid&#39;          }      },      axisTick: {            // 坐标轴小标记          show: false,       // 属性show控制显示与否，默认不显示          inside : false,      // 控制小标记是否在grid里          length :5,          // 属性length控制线长          lineStyle: {       // 属性lineStyle控制线条样式              color: &#39;#333&#39;,              width: 1          }      },      axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel          show: true,          rotate: 0,          margin: 8,          // formatter: null,          textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE              color: &#39;#333&#39;          }      },      splitLine: {                // 分隔线          show: true,        // 默认显示，属性show控制显示与否          lineStyle: {          // 属性lineStyle（详见lineStyle）控制线条样式              color: [&#39;#ccc&#39;],              width: 1,              type: &#39;solid&#39;          }      },      splitArea: {                // 分隔区域          show: false,       // 默认不显示，属性show控制显示与否          areaStyle: {       // 属性areaStyle（详见areaStyle）控制区域样式              color: [&#39;rgba(250,250,250,0.3)&#39;,&#39;rgba(200,200,200,0.3)&#39;]          }      }  },  polar : {      center : [&#39;50%&#39;, &#39;50%&#39;],    // 默认全局居中      radius : &#39;75%&#39;,      startAngle : 90,      splitNumber : 5,      name : {          show: true,          textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE              color: &#39;#333&#39;          }      },      axisLine: {            // 坐标轴线          show: true,         // 默认显示，属性show控制显示与否          lineStyle: {        // 属性lineStyle控制线条样式              color: &#39;#ccc&#39;,              width: 1,              type: &#39;solid&#39;          }      },      axisLabel: {                // 坐标轴文本标签，详见axis.axisLabel          show: false,          textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE              color: &#39;#333&#39;          }      },      splitArea : {          show : true,          areaStyle : {              color: [&#39;rgba(250,250,250,0.3)&#39;,&#39;rgba(200,200,200,0.3)&#39;]          }      },      splitLine : {          show : true,          lineStyle : {              width : 1,              color : &#39;#ccc&#39;          }      }  },</code></pre><h3 id="9-柱形图默认参数"><a href="#9-柱形图默认参数" class="headerlink" title="9.柱形图默认参数"></a>9.柱形图默认参数</h3><pre><code>  bar: {      barMinHeight: 0,            // 最小高度改为0      // barWidth: null,        // 默认自适应      barGap: &#39;30%&#39;,           // 柱间距离，默认为柱形宽度的30%，可设固定值      barCategoryGap : &#39;20%&#39;,   // 类目间柱形距离，默认为类目间距的20%，可设固定值      itemStyle: {          normal: {              // color: &#39;各异&#39;,              barBorderColor: &#39;#fff&#39;,         // 柱条边线              barBorderRadius: 0,            // 柱条边线圆角，单位px，默认为0              barBorderWidth: 1,             // 柱条边线线宽，单位px，默认为1              label: {                  show: false                                          // position: 默认自适应，水平布局为&#39;top&#39;，垂直布局为&#39;right&#39;，可选为                                          // &#39;inside&#39;|&#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39;                                          // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE              }          },          emphasis: {              // color: &#39;各异&#39;,              barBorderColor: &#39;rgba(0,0,0,0)&#39;,            // 柱条边线              barBorderRadius: 0,                // 柱条边线圆角，单位px，默认为0              barBorderWidth: 1,                     // 柱条边线线宽，单位px，默认为1              label: {                  show: false                  // position: 默认自适应，水平布局为&#39;top&#39;，垂直布局为&#39;right&#39;，可选为                  //           &#39;inside&#39;|&#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39;                  // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE              }          }      }  },</code></pre><h3 id="10-折线图默认参数"><a href="#10-折线图默认参数" class="headerlink" title="10.折线图默认参数"></a>10.折线图默认参数</h3><pre><code>  line: {      itemStyle: {          normal: {              // color: 各异,              label: {                  show: false                  // position: 默认自适应，水平布局为&#39;top&#39;，垂直布局为&#39;right&#39;，可选为                  //           &#39;inside&#39;|&#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39;                  // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE              },              lineStyle: {                  width: 2,                  type: &#39;solid&#39;,                  shadowColor : &#39;rgba(0,0,0,0)&#39;, //默认透明                  shadowBlur: 5,                  shadowOffsetX: 3,                  shadowOffsetY: 3              }          },          emphasis: {              // color: 各异,              label: {                  show: false                  // position: 默认自适应，水平布局为&#39;top&#39;，垂直布局为&#39;right&#39;，可选为                  //           &#39;inside&#39;|&#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39;                  // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE              }          }      },      //smooth : false,      //symbol: null,             // 拐点图形类型      symbolSize: 2,          // 拐点图形大小      //symbolRotate : null,       // 拐点图形旋转控制      showAllSymbol: false                   // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）  },</code></pre><h3 id="11-K线图默认参数"><a href="#11-K线图默认参数" class="headerlink" title="11.K线图默认参数"></a>11.K线图默认参数</h3><pre><code>  k: {      // barWidth : null              // 默认自适应      // barMaxWidth : null           // 默认自适应      itemStyle: {          normal: {              color: &#39;#fff&#39;,      // 阳线填充颜色              color0: &#39;#00aa11&#39;,  // 阴线填充颜色              lineStyle: {                  width: 1,                  color: &#39;#ff3200&#39;,    // 阳线边框颜色                  color0: &#39;#00aa11&#39;          // 阴线边框颜色              }          },          emphasis: {              // color: 各异,              // color0: 各异          }      }  },</code></pre><h3 id="12-散点图默认参数"><a href="#12-散点图默认参数" class="headerlink" title="12.散点图默认参数"></a>12.散点图默认参数</h3><pre><code>  scatter: {      //symbol: null,         // 图形类型      symbolSize: 4,       // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2      //symbolRotate : null,   // 图形旋转控制      large: false,        // 大规模散点图      largeThreshold: 2000,   // 大规模阀值，large为true且数据量&gt;largeThreshold才启用大规模模式      itemStyle: {          normal: {              // color: 各异,              label: {                  show: false                  // position: 默认自适应，水平布局为&#39;top&#39;，垂直布局为&#39;right&#39;，可选为                  //           &#39;inside&#39;|&#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39;                  // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE              }          },          emphasis: {              // color: &#39;各异&#39;              label: {                  show: false                  // position: 默认自适应，水平布局为&#39;top&#39;，垂直布局为&#39;right&#39;，可选为                  //           &#39;inside&#39;|&#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39;                  // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE              }          }      }  },</code></pre><h3 id="13-雷达图默认参数"><a href="#13-雷达图默认参数" class="headerlink" title="13.雷达图默认参数"></a>13.雷达图默认参数</h3><pre><code>  radar : {      itemStyle: {          normal: {              // color: 各异,              label: {                  show: false              },              lineStyle: {                  width: 2,                  type: &#39;solid&#39;              }          },          emphasis: {              // color: 各异,              label: {                  show: false              }          }      },      //symbol: null,          // 拐点图形类型      symbolSize: 2          // 可计算特性参数，空数据拖拽提示图形大小      //symbolRotate : null,    // 图形旋转控制  },</code></pre><h3 id="14-饼图默认参数"><a href="#14-饼图默认参数" class="headerlink" title="14.饼图默认参数"></a>14.饼图默认参数</h3><pre><code>  pie: {      center : [&#39;50%&#39;, &#39;50%&#39;],          // 默认全局居中      radius : [0, &#39;75%&#39;],      clockWise : false,             // 默认逆时针      startAngle: 90,      minAngle: 0,                 // 最小角度改为0      selectedOffset: 10,         // 选中是扇区偏移量      itemStyle: {          normal: {              // color: 各异,              borderColor: &#39;#fff&#39;,              borderWidth: 1,              label: {                  show: true,                  position: &#39;outer&#39;                  // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE              },              labelLine: {                  show: true,                  length: 20,                  lineStyle: {                      // color: 各异,                      width: 1,                      type: &#39;solid&#39;                  }              }          },          emphasis: {              // color: 各异,              borderColor: &#39;rgba(0,0,0,0)&#39;,              borderWidth: 1,              label: {                  show: false                  // position: &#39;outer&#39;                  // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE              },              labelLine: {                  show: false,                  length: 20,                  lineStyle: {                      // color: 各异,                      width: 1,                      type: &#39;solid&#39;                  }              }          }      }  },  map: {      mapType: &#39;china&#39;,   // 各省的mapType暂时都用中文      mapLocation: {          x : &#39;center&#39;,          y : &#39;center&#39;          // width    // 自适应          // height   // 自适应      },      showLegendSymbol : true,       // 显示图例颜色标识（系列标识的小圆点），存在legend时生效      itemStyle: {          normal: {              // color: 各异,              borderColor: &#39;#fff&#39;,              borderWidth: 1,              areaStyle: {                  color: &#39;#ccc&#39;   //rgba(135,206,250,0.8)              },              label: {                  show: false,                  textStyle: {                      color: &#39;rgba(139,69,19,1)&#39;                  }              }          },          emphasis: {                // 也是选中样式              // color: 各异,              borderColor: &#39;rgba(0,0,0,0)&#39;,              borderWidth: 1,              areaStyle: {                  color: &#39;rgba(255,215,0,0.8)&#39;              },              label: {                  show: false,                  textStyle: {                      color: &#39;rgba(139,69,19,1)&#39;                  }              }          }      }  },  force : {      // 数据map到圆的半径的最小值和最大值      minRadius : 10,      maxRadius : 20,      density : 1.0,      attractiveness : 1.0,      // 初始化的随机大小位置      initSize : 300,      // 向心力因子，越大向心力越大      centripetal : 1,      // 冷却因子      coolDown : 0.99,      // 分类里如果有样式会覆盖节点默认样式      itemStyle: {          normal: {              // color: 各异,              label: {                  show: false                  // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE              },              nodeStyle : {                  brushType : &#39;both&#39;,                  color : &#39;#f08c2e&#39;,                  strokeColor : &#39;#5182ab&#39;              },              linkStyle : {                  strokeColor : &#39;#5182ab&#39;              }          },          emphasis: {              // color: 各异,              label: {                  show: false                  // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE              },              nodeStyle : {},              linkStyle : {}          }      }  },  chord : {      radius : [&#39;65%&#39;, &#39;75%&#39;],      center : [&#39;50%&#39;, &#39;50%&#39;],      padding : 2,      sort : &#39;none&#39;,   // can be &#39;none&#39;, &#39;ascending&#39;, &#39;descending&#39;      sortSub : &#39;none&#39;, // can be &#39;none&#39;, &#39;ascending&#39;, &#39;descending&#39;      startAngle : 90,      clockWise : false,      showScale : false,      showScaleText : false,      itemStyle : {          normal : {              label : {                  show : true                  // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE              },              lineStyle : {                  width : 0,                  color : &#39;#000&#39;              },              chordStyle : {                  lineStyle : {                      width : 1,                      color : &#39;#666&#39;                  }              }          },          emphasis : {              lineStyle : {                  width : 0,                  color : &#39;#000&#39;              },              chordStyle : {                  lineStyle : {                      width : 2,                      color : &#39;#333&#39;                  }              }          }      }  },  island: {      r: 15,      calculateStep: 0.1  // 滚轮可计算步长 0.1 = 10%  },  markPoint : {      symbol: &#39;pin&#39;,         // 标注类型      symbolSize: 10,            // 标注大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2      //symbolRotate : null, // 标注旋转控制      itemStyle: {          normal: {              // color: 各异，              // borderColor: 各异,     // 标注边线颜色，优先于color              borderWidth: 2,         // 标注边线线宽，单位px，默认为1              label: {                  show: true,                  position: &#39;inside&#39;    // 可选为&#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39;                  // textStyle: null    // 默认使用全局文本样式，详见TEXTSTYLE              }          },          emphasis: {              // color: 各异              label: {                  show: true                  // position: &#39;inside&#39;    // &#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39;                  // textStyle: null     // 默认使用全局文本样式，详见TEXTSTYLE              }          }      }  },  markLine : {      // 标线起始和结束的symbol介绍类型，如果都一样，可以直接传string      symbol: [&#39;circle&#39;, &#39;arrow&#39;],       // 标线起始和结束的symbol大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2      symbolSize: [2, 4],      // 标线起始和结束的symbol旋转控制      //symbolRotate : null,      itemStyle: {          normal: {              // color: 各异,           // 标线主色，线色，symbol主色              // borderColor: 随color,       // 标线symbol边框颜色，优先于color              borderWidth: 2,          // 标线symbol边框线宽，单位px，默认为2              label: {                  show: false,                  // 可选为 &#39;start&#39;|&#39;end&#39;|&#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39;                  position: &#39;inside&#39;,                   textStyle: {         // 默认使用全局文本样式，详见TEXTSTYLE                      color: &#39;#333&#39;                  }              },              lineStyle: {                  // color: 随borderColor,    // 主色，线色，优先级高于borderColor和color                  // width: 随borderWidth,    // 优先于borderWidth                  type: &#39;solid&#39;,                  shadowColor : &#39;rgba(0,0,0,0)&#39;, //默认透明                  shadowBlur: 5,                  shadowOffsetX: 3,                  shadowOffsetY: 3              }          },          emphasis: {              // color: 各异              label: {                  show: false                  // position: &#39;inside&#39;   // &#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39;                  // textStyle: null    // 默认使用全局文本样式，详见TEXTSTYLE              },              lineStyle : {}          }      }  },  textStyle: {      decoration: &#39;none&#39;,      fontFamily: &#39;Arial, Verdana, sans-serif&#39;,      fontFamily2: &#39;微软雅黑&#39;,    // IE8- 字体模糊并且不支持不同字体混排，额外指定一份      fontSize: 12,      fontStyle: &#39;normal&#39;,      fontWeight: &#39;normal&#39;  },</code></pre><h3 id="15-默认标志图形类型列表"><a href="#15-默认标志图形类型列表" class="headerlink" title="15.默认标志图形类型列表"></a>15.默认标志图形类型列表</h3><pre><code>  symbolList : [    &#39;circle&#39;, &#39;rectangle&#39;, &#39;triangle&#39;, &#39;diamond&#39;,    &#39;emptyCircle&#39;, &#39;emptyRectangle&#39;, &#39;emptyTriangle&#39;, &#39;emptyDiamond&#39;  ],  loadingText : &#39;Loading...&#39;,</code></pre><h3 id="16-可计算特性配置，孤岛，提示颜色"><a href="#16-可计算特性配置，孤岛，提示颜色" class="headerlink" title="16.可计算特性配置，孤岛，提示颜色"></a>16.可计算特性配置，孤岛，提示颜色</h3><pre><code>  calculable: false,                       // 默认关闭可计算特性  calculableColor: &#39;rgba(255,165,0,0.6)&#39;,       // 拖拽提示边框颜色  calculableHolderColor: &#39;#ccc&#39;,               // 可计算占位提示颜色  nameConnector: &#39; &amp; &#39;,  valueConnector: &#39; : &#39;,  animation: true,  animationThreshold: 2500,           // 动画元素阀值，产生的图形原素超过2500不出动画  addDataAnimation: true,         // 动态数据接口是否开启动画效果  animationDuration: 2000,  animationEasing: &#39;ExponentialOut&#39;             //BounceOut</code></pre><h2 id="3-Echars官方案例"><a href="#3-Echars官方案例" class="headerlink" title="3. Echars官方案例"></a>3. Echars官方案例</h2><ul><li><a href="https://www.echartsjs.com/examples/zh/index.html" target="_blank" rel="noopener">Echars官方案例</a></li></ul><h2 id="4-Echars社区经典模板"><a href="#4-Echars社区经典模板" class="headerlink" title="4. Echars社区经典模板"></a>4. <a href="https://gallery.echartsjs.com/explore.html" target="_blank" rel="noopener">Echars社区</a>经典模板</h2><ul><li><p><a href="https://gallery.echartsjs.com/editor.html?c=xmCAi_XNuJ" target="_blank" rel="noopener">自定义tooltip，实时获取最新geojson数据</a><br><img src="2.jpg" alt></p></li><li><p><a href="https://gallery.echartsjs.com/editor.html?c=xPkPpAWqSt" target="_blank" rel="noopener">中国地图自定义轮播</a><br><img src="1.jpg" alt></p></li><li><p>……</p></li></ul><!-- ## 5.Echars在Vue项目中的使用 -->]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-Native入坑之路 (一)</title>
      <link href="/2019/06/22/react-native-ru-keng-zhi-lu/"/>
      <url>/2019/06/22/react-native-ru-keng-zhi-lu/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=525454434&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="React-Native-入坑之路-一"><a href="#React-Native-入坑之路-一" class="headerlink" title="React-Native 入坑之路(一)"></a>React-Native 入坑之路(一)</h1><hr><h2 id="1-React-navigation-使用"><a href="#1-React-navigation-使用" class="headerlink" title="1. React-navigation 使用"></a>1. React-navigation 使用</h2><h3 id="1-导入依赖库"><a href="#1-导入依赖库" class="headerlink" title="1.导入依赖库"></a>1.导入依赖库</h3><pre><code>   npm install react-navigation --save</code></pre><p>  然后在 package.json 文件中就可以看到，依赖库已经导入完毕：</p><pre><code>   &quot;react-native-tab-navigator&quot;: &quot;^0.3.4&quot;,</code></pre><h3 id="2-配置Navigator"><a href="#2-配置Navigator" class="headerlink" title="2. 配置Navigator"></a>2. 配置Navigator</h3><ul><li><p>引入<br><img src="1.jpg" alt></p></li><li><p>使用<br><a href="https://www.jianshu.com/p/f39f020197ef" target="_blank" rel="noopener">React-navigation使用攻略</a></p></li></ul><h2 id="2-react-native-px2dp"><a href="#2-react-native-px2dp" class="headerlink" title="2. react-native-px2dp"></a>2. react-native-px2dp</h2><ul><li><p>安装<br>  npm install react-native-px2dp –save</p></li><li><p>使用<a href="https://www.jianshu.com/p/7836523b4d20" target="_blank" rel="noopener">React native 分辨率适配(px,dp)</a></p><pre><code>import px2dp from &#39;../../util/px2dp&#39;&#39;use strict&#39;;import {Dimensions} from &#39;react-native&#39;const deviceH = Dimensions.get(&#39;window&#39;).heightconst deviceW = Dimensions.get(&#39;window&#39;).widthconst basePx = 750export default function px2dp(px) {    return px *  deviceW / basePx}</code></pre></li></ul><h2 id="3-Dimensions-获取当前屏幕的宽高"><a href="#3-Dimensions-获取当前屏幕的宽高" class="headerlink" title="3. Dimensions 获取当前屏幕的宽高"></a>3. Dimensions 获取当前屏幕的宽高</h2><pre><code>const { deviceWidth, deviceHeight } = Dimensions.get(&#39;window&#39;);</code></pre><h2 id="4-AsyncStorage-本都存储"><a href="#4-AsyncStorage-本都存储" class="headerlink" title="4. AsyncStorage 本都存储"></a>4. AsyncStorage 本都存储</h2><p><a href="https://www.jianshu.com/p/abf4e19f245c" target="_blank" rel="noopener">ReactNative之AsyncStorage本地存储</a>:<a href="https://www.jianshu.com/p/abf4e19f245c" target="_blank" rel="noopener">https://www.jianshu.com/p/abf4e19f245c</a></p><h2 id="5-StatusBar的使用详解"><a href="#5-StatusBar的使用详解" class="headerlink" title="5. StatusBar的使用详解"></a>5. StatusBar的使用详解</h2><p><a href="https://www.jianshu.com/p/cff86e199c93" target="_blank" rel="noopener">StatusBar的使用详解</a>:<a href="https://www.jianshu.com/p/cff86e199c93" target="_blank" rel="noopener">https://www.jianshu.com/p/cff86e199c93</a></p><h2 id="6-ViewPagerAndroid"><a href="#6-ViewPagerAndroid" class="headerlink" title="6. ViewPagerAndroid"></a>6. ViewPagerAndroid</h2><p><a href="https://reactnative.cn/docs/next/viewpagerandroid.html" target="_blank" rel="noopener">官网</a><br><a href="https://www.jianshu.com/p/699a3b7da848" target="_blank" rel="noopener">React-Native ViewPagerAndroid使用</a></p><h2 id="7-React-Native-高德地图组件的使用（react-native-amap3d）"><a href="#7-React-Native-高德地图组件的使用（react-native-amap3d）" class="headerlink" title="7. React Native 高德地图组件的使用（react-native-amap3d）"></a>7. React Native 高德地图组件的使用（react-native-amap3d）</h2><p><a href="https://www.jianshu.com/p/fe90fc6a0308" target="_blank" rel="noopener">高德地图组件的使用</a>:<a href="https://www.jianshu.com/p/fe90fc6a0308" target="_blank" rel="noopener">https://www.jianshu.com/p/fe90fc6a0308</a></p><p><a href="https://blog.csdn.net/IT_luntan/article/details/78982497" target="_blank" rel="noopener">高德地图组件react-native-amap3d</a></p>]]></content>
      
      
      <categories>
          
          <category> RN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Native 搭建小白教程</title>
      <link href="/2019/05/06/react-native-da-jian-xiao-bai-jiao-cheng/"/>
      <url>/2019/05/06/react-native-da-jian-xiao-bai-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1347529350&auto=1&height=66"></iframe></div><p>前言：因为电脑是 windows 系统，为了开始 React-Native 的入坑之路，只能硬着头皮上了，搭建环境的路上走了很多的坑，现在我把我成功搭建的路子记录下来，希望帮助大家少走弯路，也让我以后再搭建的时候，有个记忆，现在正式开始……</p><h1 id="windows-环境下搭建-React-Native-开发环境"><a href="#windows-环境下搭建-React-Native-开发环境" class="headerlink" title="windows 环境下搭建 React-Native 开发环境"></a>windows 环境下搭建 React-Native 开发环境</h1><hr><h1 id="RN-搭建开发环境-官网"><a href="#RN-搭建开发环境-官网" class="headerlink" title="RN-搭建开发环境-官网"></a>RN-搭建开发环境-官网</h1><ul><li><a href="https://reactnative.cn/docs/getting-started.html" target="_blank" rel="noopener">RN-搭建开发环境-官网</a>:<a href="https://reactnative.cn/docs/getting-started.html" target="_blank" rel="noopener">https://reactnative.cn/docs/getting-started.html</a></li></ul><h1 id="详细搭建过程"><a href="#详细搭建过程" class="headerlink" title="详细搭建过程"></a>详细搭建过程</h1><h2 id="第一步：安装-Node"><a href="#第一步：安装-Node" class="headerlink" title="第一步：安装 Node"></a>第一步：安装 Node</h2><pre><code>Node  (&gt;8.3)</code></pre><p>安装完 Node 后建议设置 npm 镜像以加速后面的过程（或使用科学上网工具）。</p><pre><code>npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global</code></pre><p>注意：不要使用 cnpm！cnpm 安装的模块路径比较奇怪，packager 不能正常识别！</p><h2 id="第二步：-安装-yarn"><a href="#第二步：-安装-yarn" class="headerlink" title="第二步： 安装 yarn"></a>第二步： 安装 yarn</h2><p>Yarn 是 Facebook 提供的替代 npm 的工具，可以加速 node 模块的下载。安装 yarn 需要用 npm</p><pre><code>npm install -g yarn</code></pre><p>安装完 yarn 后同理也要设置镜像源：</p><pre><code>yarn config set registry https://registry.npm.taobao.org --globalyarn config set disturl https://npm.taobao.org/dist --global</code></pre><p>安装完 yarn 之后就可以用 yarn 代替 npm 了，例如用 yarn 代替 npm install 命令，用 yarn add 代替 npm install.</p><h2 id="第三步-React-Native-命令行工具（react-native-cli）"><a href="#第三步-React-Native-命令行工具（react-native-cli）" class="headerlink" title="第三步: React Native 命令行工具（react-native-cli）"></a>第三步: React Native 命令行工具（react-native-cli）</h2><p>React Native 的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。</p><pre><code> npm install -g react-native-cli</code></pre><h2 id="第四步-Python2-x-不支持-3-x"><a href="#第四步-Python2-x-不支持-3-x" class="headerlink" title="第四步: Python2.x (不支持 3.x)"></a>第四步: Python2.x (不支持 3.x)</h2><p><a href="https://www.python.org/downloads/" target="_blank" rel="noopener">Python 的官网下载地址</a>:<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">https://www.python.org/downloads/</a></p><p><img src="python.jpg" alt></p><h2 id="第五步-JDK-1-8-不支持更高版本"><a href="#第五步-JDK-1-8-不支持更高版本" class="headerlink" title="第五步: JDK (==1.8 , 不支持更高版本)"></a>第五步: JDK (==1.8 , 不支持更高版本)</h2><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">React Native 要求 JDK 的版本为 1.8，官网的下载地址</a>:<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p><p>选择本系统合适的版本，即可，本人是 Windows x64 版本，即：</p><p><img src="jdk.jpg" alt></p><p>安装好了之后，可以测试一下是否安装好 打开命令窗口终端（按住 windows+r ） 输入 java -version 回车 如果出现下图就安装成功了，如果不行，重启一下电脑再试<br><img src="2.jpg" alt></p><h2 id="第六步-安装-Android-环境"><a href="#第六步-安装-Android-环境" class="headerlink" title="第六步: 安装 Android 环境"></a>第六步: 安装 Android 环境</h2><p><a href="http://www.android-studio.org/index.php/download" target="_blank" rel="noopener">安装 Android 环境，首先先安装 Android Studio，下载地址</a>;<a href="http://www.android-studio.org/index.php/download" target="_blank" rel="noopener">http://www.android-studio.org/index.php/download</a></p><p><img src="1.jpg" alt></p><p>下载下来的是一个可安装程序，点击安装即可，在点击“Next”过程，有一步需要指定 Android SDK 的路径，如果之前电脑中已经存在 SDK，可以指定该路径，后续就可以不用下载 SDK；由于本地没有安装过 SDK 的场景，这里暂时可以指定一个后续将保存 SDK 的路径。</p><p>点击“Finish”后，开始自动下载 SDK，此时根据网速的快慢，决定这个步骤的时间的长短，下载完成后，则会进行 Android Studio 的欢迎画面，如图</p><p><img src="3.jpg" alt></p><h3 id="配置环境变量（特别重要）"><a href="#配置环境变量（特别重要）" class="headerlink" title="配置环境变量（特别重要）"></a>配置环境变量（特别重要）</h3><ul><li>鼠标右键点击计算机，选择属性之后再按下图操作<br><img src="5.jpg" alt></li></ul><p>然后在编辑系统变量的这个框里面的变量值中操作以下步骤</p><ol><li><p>找到 Android SDK 的目录的路径复制添加到 path<br><img src="6.jpg" alt></p></li><li><p>找到 android sdk 中 platform-tools 文件的路径地址添加到 pah，记住一定要打分号哦，跟前一个路径区分开</p><p> 例如我的路径就是 F:\android-sdk_r24.4.1-windows\android-sdk-windows\platform-tools<br> <img src="7.jpg" alt></p></li><li><p>找到<code>android sdk 中 tools</code>文件的路径地址添加到<code>pah</code> 最后点击确定 确定 确定 就完事了</p></li></ol><p>然后打开命令终端 <code>（windows + r）</code> 输入 adb，测试一下，只要没有报错，就成功了</p><p><code>我们再把java sdk配置了，按下图操作</code></p><p><img src="8.jpg" alt></p><p>我因为第一次搭建失败了，查了很久了，我添加了一个 Android sdk 的系统变量，第二次搭建就成功了，不知道是不是这个原因，最好添加一下吧，以防万一</p><p><img src="9.jpg" alt></p><p>Android SDK 默认的应该是在 C:\Users\Administrator\AppData\Local\Android\Sdk</p><p>这个地方我也有一个疑问，为什么我的 android sdk 压缩包是解压在 F 盘里的，C 盘也会有一个 sdk，这个地方的配置<code>要用c盘的sdk</code>，记住了</p><h2 id="第七步-安装一个模拟器-我选择的是夜神模拟器"><a href="#第七步-安装一个模拟器-我选择的是夜神模拟器" class="headerlink" title="第七步: 安装一个模拟器 我选择的是夜神模拟器"></a>第七步: 安装一个模拟器 我选择的是夜神模拟器</h2><ul><li>安装夜神模拟器，安装好之后，最好将分辨率调成<code>手机端</code><br><a href="https://www.yeshen.com/" target="_blank" rel="noopener">夜神官网</a>:<a href="https://www.yeshen.com/" target="_blank" rel="noopener">https://www.yeshen.com/</a></li></ul><h2 id="第八步-打开命令窗口，输入-react-native-init-firstdemo-创建项目名为firstdemo的文件夹"><a href="#第八步-打开命令窗口，输入-react-native-init-firstdemo-创建项目名为firstdemo的文件夹" class="headerlink" title="第八步: 打开命令窗口，输入 react-native init firstdemo 创建项目名为firstdemo的文件夹"></a>第八步: 打开命令窗口，输入 react-native init firstdemo 创建项目名为<code>firstdemo</code>的文件夹</h2><p>之后在 firstdemo 项目目录中找到 android 目录，创建一个文件，如下图</p><p><img src="10.jpg" alt><br>然后内容为：<code>sdk.dir=android sdk</code>目录路径，如下图，记住，一定是<code>双斜杠</code>，</p><p><img src="11.jpg" alt></p><h2 id="第九步-连接模拟器，运行项目"><a href="#第九步-连接模拟器，运行项目" class="headerlink" title="第九步: 连接模拟器，运行项目"></a>第九步: 连接模拟器，运行项目</h2><p>打开项目目录，按住 shift 键，鼠标右键点击，选择在此处打开命令窗口，输入 react-native start （启动项目服务进程），如下图</p><p><img src="12.jpg" alt></p><p>接下来，刚刚的命令窗口别关闭了，重新打开一个命令窗口，连接夜神模拟器</p><h3 id="9-1-打开夜神模拟器"><a href="#9-1-打开夜神模拟器" class="headerlink" title="9.1 打开夜神模拟器"></a>9.1 打开夜神模拟器</h3><h3 id="9-2-重新打开一个命令窗口，执行命令-adb-connect-127-0-0-1-62001以连接模拟器，（这个地方主义一下，端口号62001，是夜神模拟器默认的，如果你是其他的模拟器，记得查阅一下，默认端口号是多少）如下图："><a href="#9-2-重新打开一个命令窗口，执行命令-adb-connect-127-0-0-1-62001以连接模拟器，（这个地方主义一下，端口号62001，是夜神模拟器默认的，如果你是其他的模拟器，记得查阅一下，默认端口号是多少）如下图：" class="headerlink" title="9.2 重新打开一个命令窗口，执行命令 adb connect 127.0.0.1:62001以连接模拟器，（这个地方主义一下，端口号62001，是夜神模拟器默认的，如果你是其他的模拟器，记得查阅一下，默认端口号是多少）如下图："></a>9.2 重新打开一个命令窗口，执行命令 <code>adb connect 127.0.0.1:62001</code>以连接模拟器，（这个地方主义一下，端口号<code>62001</code>，是夜神模拟器默认的，如果你是其他的模拟器，记得查阅一下，默认端口号是多少）如下图：</h3><p><img src="13.jpg" alt></p><h3 id="9-3-再执行命令-react-native-run-android-这里需要说明一下，第一次启动这个命令的话，他要下载一些依赖的东西，最好是要有-t-z，不然会很慢，也可能会失败，这直接关系到最后能不能成功搭建环境，我这里是已经执行过一次这个命令了，如下图："><a href="#9-3-再执行命令-react-native-run-android-这里需要说明一下，第一次启动这个命令的话，他要下载一些依赖的东西，最好是要有-t-z，不然会很慢，也可能会失败，这直接关系到最后能不能成功搭建环境，我这里是已经执行过一次这个命令了，如下图：" class="headerlink" title="9.3 再执行命令 react-native run-android ,这里需要说明一下，第一次启动这个命令的话，他要下载一些依赖的东西，最好是要有 t z，不然会很慢，也可能会失败，这直接关系到最后能不能成功搭建环境，我这里是已经执行过一次这个命令了，如下图："></a>9.3 再执行命令 react-native run-android ,这里需要说明一下，第一次启动这个命令的话，他要下载一些依赖的东西，最好是要有 t z，不然会很慢，也可能会失败，这直接关系到最后能不能成功搭建环境，我这里是已经执行过一次这个命令了，如下图：</h3><p><img src="14.jpg" alt><br><img src="15.jpg" alt></p><p>成功之后，你会看到你的模拟器自动打开了一个 app，但是整个页面都是红色的，想报错一样，别慌张，还有最后一步</p><p><img src="16.jpg" alt><br><img src="17.jpg" alt></p><p>输入电脑地址(<code>ipconfig =&gt; IPv4 地址</code>)+ 端口号<code>8081</code>:如图<br><img src="21.jpg" alt></p><p><img src="18.jpg" alt></p><p>最后再运行命令 react-native run-android 模拟器会出现 app 界面，</p><p><img src="20.jpg" alt></p><p>好了，恭喜你，环境搭建好了，开始你的 RN 踩坑之路吧，</p>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js常用数组操作方法</title>
      <link href="/2019/01/22/js-chang-yong-shu-zu-cao-zuo-fang-fa/"/>
      <url>/2019/01/22/js-chang-yong-shu-zu-cao-zuo-fang-fa/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><hr><p>你真的了解JS数组的那些方法吗？</p><blockquote><p>寄语：<br>JS数组的方法非常的丰富和琐碎，学习和使用过程中总是需要反复的记忆、查看文档，但作为JS基础这样真的不应该，我们应该把它记得滚瓜烂熟，深入理解才对。<br>但是要怎样才能做到呢？这正是我也本文的初衷，根据个人的经验总结了一下，希望能够帮助和我一样困惑的人，搞定这个头疼的问题。</p></blockquote><p><strong>数组的方法</strong><br>JavaScript的数组方法包括数组原型的方法、构造函数的方法（ES6新增部分）<br>针对每一个方法我们主要了解四个方面：<strong>作用、参数、返回值、原数组是否改变</strong></p><p><strong>（一）. 原型上的方法</strong></p><p><strong>1. push()</strong><br>作用：向数组的末尾添加一项或多项<br>参数：ele1[, ele2[, …[, elen]]]<br>返回值：添加元素后数组的长度<br>原数组是否改变：是</p><p>let arr = [1, 2, 3];<br>let temp = arr.push(‘a’, ‘b’);<br>console.log(arr, temp); // [1, 2, 3, ‘a’, ‘b’] 5</p><p><strong>2. pop()</strong><br>作用：删除数组最后一项<br>参数：无<br>返回值：删除的那一项<br>原数组是否改变：是</p><p>let arr = [1, 2, 3];<br>let temp = arr.pop();<br>console.log(arr, temp); // [1, 2] 3</p><p><strong>3. unshift()</strong><br>作用：向数组开头添加一项或多项<br>参数：ele1[, ele2[, …[, elen]]]<br>返回值：添加元素后数组的长度<br>原数组是否改变：是<br>let arr = [1, 2, 3];<br>let temp = arr.unshift(‘a’, ‘b’);<br>console.log(arr, temp); // [‘a’, ‘b’, 1, 2, 3] 5</p><p><strong>4. splice()</strong><br>作用：删除、插入、替换数组项<br>参数：startIndex[, deleteCount[, item1[, …[, itemN]]]]<br>返回值：删除项组成的数组<br>原数组是否改变：是<br>let arr = [1, 2, 3];</p><p>// 插入元素<br>let temp = arr.splice(1, 0, ‘a’, ‘b’); // 在索引1的位置插入元素’a’和’b’<br>console.log(arr, temp); // [1, ‘a’, ‘b’, 2, 3] []</p><p>// 删除元素<br>let temp1 = arr.splice(1, 2); // 删除从索引1的位置开始的2项<br>console.log(arr, temp1); // [1, 2, 3] [‘a’, ‘b’]</p><p>// 替换一个元素<br>let temp2 = arr.splice(1, 1, ‘a’); // 将索引1的位置的元素替换为’a’<br>console.log(arr, temp2); // [1, ‘a’, 3 ] [2]</p><p>// 替换多个元素<br>let temp3 = arr.splice(0, 2, ‘b’, ‘c’); // 将索引0的位置开始的两项，替换成’b‘和’c‘<br>console.log(arr, temp3); // [’b‘, ‘c’, 3] [1, ‘a’]</p><p>// 只传第一个参数，则删除从第一个参数指定的位置到数组结尾的所有项<br>let temp4 = arr.splice(0); //从索引0的位置开始，删除后面的所有项<br>console.log(arr, temp4); // [] [’b‘, ‘c’, 3]</p><p><strong>6. copyWithin()</strong></p><p>作用：将数组指定位置（start到end）的元素复制到当前数组的其他位置（target开始），这种复制会替换原位置的元素（ES6新增）<br>参数说明：target[,start[,end]]<br>参数说明：</p><p>target: 复制的目标位置（包括），即要被替换的元素开始的位置<br>start: 要copy的元素的开始位置，默认0<br>end: 要copy的元素的结束位置，默认为数组最后一个元素</p><p>返回值：复制替换之后的数组<br>原数组是否改变：是<br>let arr = [1, 2, 3, 4, 5];<br>// 用索引0<del>4范围内的元素，替换索引3</del>4范围内的元素，因为要替换的位置只有两个，所以只将4，5替换为了1，2<br>let temp = arr.copyWithin(3);<br>console.log(arr, temp); //  [1, 2, 3, 1, 2] [1, 2, 3, 1, 2]</p><p>let arr1 = [1, 2, 3, 4, 5];<br>// 用索引2<del>4范围内的元素，替换索引3</del>4范围内的元素，因为要替换的位置只有两个，所以只将4，5替换为了3，4<br>let temp1 = arr1.copyWithin(3, 2);<br>console.log(arr1, temp1); // [1, 2, 3, 3, 4] [1, 2, 3, 3, 4]</p><blockquote><p>小结：<br>总结上述的描述，copyWithin的作用就是在数组长度的范围内，复制start(包括)到end(不包括)范围内的元素，然后用上述的元替换掉从target（包括）开始到数组结尾的元素，能替换多少就替换多少</p></blockquote><p><strong>7. reverse</strong><br>作用：翻转原数组<br>参数：无<br>返回值：翻转后的数组<br>原数组是否改变：是<br>let arr = [1, 2, 3];<br>let temp = arr.reverse();<br>console.log(arr, temp); // [ 3, 2, 1 ] [ 3, 2, 1 ]</p><p><strong>8. sort()</strong><br>作用：数组排序<br>参数：compareFunction<br>参数说明：</p><p>compareFunction返回值大于0时调换当前比对项的顺序，否则顺序不 变;<br>参数可以不传，不传默认按照Unicode编码的顺序排列<br>返回值：排序后的数组<br>原数组是否改变：是<br>// 数组从小到大排序<br>let arr = [1, 4, 6, 7, 8, 3, 2];<br>let temp = arr.sort((a, b) =&gt; {<br>    return a - b;<br>})<br>console.log(arr, temp); // [ 1, 2, 3, 4, 6, 7, 8 ] [ 1, 2, 3, 4, 6, 7, 8 ]</p><p>// 一个实用的数组排序的例子，根据对象元素的排序，排序对象在数组中的位置<br>let objArr = [{id: 3, name: “lilei”},{id: 1, name: “hanmeimei”},{id: 2, name: “yimi”}];<br>let tempArr = objArr.sort((a, b) =&gt; {<br>    // 按照id从小到大的顺序，对数组中的对象进行排序<br>    // 这个示例说明回调函数的形参a,b实际就是数组中当前进行比对的两个元素<br>    return a.id - b.id;<br>});<br>console.log(objArr); //  [{id: 1, name: ‘hanmeimei’}, {id: 2, name: ‘yimi’}, { id: 3, name: ‘lilei’ }]<br>console.log(tempArr); // [{id: 1, name: ‘hanmeimei’}, {id: 2, name: ‘yimi’}, { id: 3, name: ‘lilei’}]</p><p><strong>9. concat</strong><br>作用：基于当前的数组拼接数组<br>参数：value1[, value2[, …[, valueN]]<br>参数说明：</p><p>参数的类型可以是任意类型。<br>不是数组类型直接按顺序拼接到数组末尾，数组类型的则将数组元素逐一取出拼接到数组末尾<br>不传则相当于复制数组</p><p>返回值：拼接后的数组<br>原数组是否改变：否</p><p>let arr = [1,2];<br>let temp = arr.concat(‘a’, {id:1}, [‘lilei’, ‘hanmeimei’]);<br>console.log(arr, temp); // [ 1, 2 ] [ 1, 2, ‘a’, { id: 1 }, ‘lilei’, ‘hanmeimei’]</p><p>// 用于复制数组<br>let arr = [1, 2];<br>let temp = arr.concat();<br>console.log(arr, temp);  // [ 1, 2 ] [ 1, 2 ]</p><p><strong>10. slice()</strong><br>作用：基于当前数组的一项或多项创建一个新的数组<br>参数：startIndex[,endIndex]<br>参数说明：返回的元素包含startIndex位置的元素，但不包括endIndex位置的元素<br>返回值：返回截取的元素组成的数组<br>原数组是否改变：否</p><p>let arr = [0, 1, 2, 3, 4];<br>let temp = arr.slice(1,3); // 返回从索引1（包括）位置到索引3（不包括）位置之前的元素<br>console.log(arr, temp); // [0, 1, 2, 3, 4] [1, 2]</p><p>// 用于复制数组<br>let arr = [0, 1, 2, 3, 4];<br>let temp = arr.slice(0); // 返回从索引0（包括）位置到数组结尾的所有元素<br>console.log(arr, temp); // [0, 1, 2, 3, 4] [0, 1, 2, 3, 4]</p><p><strong>11.indexOf()</strong>:<br>作用：从数组开头查找元素在数组中的索引位置（ES5的方法）<br>参数：searchElement[, fromIndex]<br>返回值：searchElement在数组中的索引，没找到searchElement则返回-1<br>原数组是否改变：否<br>let arr = [1, 2, 3, 4, 5, 6, 2];<br>// 从数组开头开始查找<br>let temp = arr.indexOf(2);<br>console.log(arr, temp); // [ 1, 2, 3, 4, 5, 6, 2 ] 1<br>// 从指定的位置开始查找<br>let temp1 = arr.indexOf(2,3); // 从索引3(包括)的位置向后查找元素2<br>console.log(arr, temp1); // [ 1, 2, 3, 4, 5, 6, 2 ] 6<br>复制代码</p><p><strong>12.lastIndexOf():</strong><br>作用：从数组结尾查找元素在数组中的索引位置（ES5的方法）<br>参数：searchElement[, fromIndex]<br>返回值：searchElement在数组中的索引，没找到searchElement则返回-1<br>原数组是否改变：否<br>let arr = [1, 2, 3, 4, 5, 6, 2];<br>// 从数组末尾开始查找<br>let temp = arr.lastIndexOf(2);<br>console.log(arr, temp); // [ 1, 2, 3, 4, 5, 6, 2 ] 6<br>// 从指定的位置开始查找<br>let temp1 = arr.lastIndexOf(2,3); // 从索引3(包括)的位置向前查找元素2<br>console.log(arr, temp1); // [ 1, 2, 3, 4, 5, 6, 2 ] 1<br>复制代码</p><p><strong>13.every():</strong><br>作用：对数组中的每一项运行给定函数，如果该函数对每一项都返回true,则返回true（ES5方法）<br>参数：callback[, thisArg]<br>参数说明：callback有三个参数item(当前项),index(当前项索引)，array(数组对象本身)<br>返回值：true 或 false<br>原数组是否改变：涉及callback，因此不确定，具体详情见下文中的原型方法的小结部分。<br>let arr = [1, 2, 3, 4];<br>let temp = arr.every((item, index, array) =&gt; {<br>    return item &gt; 2;<br>});<br>console.log(arr, temp); // [ 1, 2, 3, 4 ] false</p><p>// 方法的第二个参数可选，作用是设定第一个参数中的this指向，如果使用第二个参数，注意callback不能是箭头函数<br>// 后面的迭代方法涉及此参数的，用法相同，不在赘述<br>let arr = [1, 2, 3, 4];<br>let temp = arr.every(function(item, index, array) {<br>    return item &gt; this.id;<br>}, {id: 2});<br>console.log(arr, temp); // [ 1, 2, 3, 4 ] false<br>复制代码</p><p><strong>14.some():</strong><br>作用：对数组中的每一项运行给定函数，如果该函数对任意一项返回true,则返回true（ES5方法）<br>参数：callback[, thisArg]<br>参数说明：callback有三个参数item(当前项),index(当前项索引)，array(数组对象本身)<br>返回值：true 或 false<br>原数组是否改变：涉及callback，因此不确定，具体详情见下文中的原型方法的小结部分。<br>let arr = [1, 2, 3, 4];<br>let temp = arr.some((item, index, array) =&gt; {<br>    return item &gt; 2;<br>});<br>console.log(arr, temp); // [ 1, 2, 3, 4 ] true<br>复制代码</p><p><strong>15.filter():</strong><br>作用：对数组中的每一项运行给定函数，返回该函数返回true的项组成的数组（ES5方法）<br>参数：callback[, thisArg]<br>参数说明：callback有三个参数item(当前项),index(当前项索引)，array(数组对象本身)<br>返回值：函数返回true的项组成的数组<br>原数组是否改变：涉及callback，因此不确定，具体详情见下文中的原型方法的小结部分。<br>let arr = [1, 2, 3, 4];<br>let temp = arr.filter((item, index, array) =&gt; {<br>    return item &gt; 2;<br>});<br>console.log(arr, temp); // [ 1, 2, 3, 4 ] [3, 4]<br>复制代码</p><p><strong>16.map():</strong><br>作用：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组（ES5方法）<br>参数：callback[, thisArg]<br>参数说明：callback有三个参数item(当前项),index(当前项索引)，array(数组对象本身)<br>返回值：函数每次调用结果组成的数组<br>原数组是否改变：涉及callback，因此不确定，具体详情见下文中的原型方法的小结部分。<br>let arr = [1, 2, 3, 4];<br>let temp = arr.map((item, index, array) =&gt; {<br>    return item * item;<br>});<br>console.log(arr, temp); // [ 1, 2, 3, 4 ] [ 1, 4, 9, 16]<br>复制代码</p><p><strong>17.forEach():</strong><br>作用：对数组中的每一项运行给定函数。无返回值（ES5方法）<br>参数：callback[, thisArg]<br>参数说明：callback有三个参数item(当前项),index(当前项索引)，array(数组对象本身)<br>返回值：无<br>原数组是否改变：涉及callback，因此不确定，具体详情见下文中的原型方法的小结部分。<br>let arr = [1, 2, 3, 4];<br>let temp = arr.forEach((item, index, array) =&gt; {<br>    // 不会有返回值，但可在这里执行某些操作<br>    return item * item;<br>});<br>console.log(arr, temp); // [ 1, 2, 3, 4 ] undefined<br>复制代码<br>注意：<br>forEach在所有项都遍历完成之前，无法像for循环一样提前终止循环</p><p><strong>18.reduce():</strong><br>作用：从数组的第一项开始，逐步遍历到最后，迭代数组的所有项（ES5方法）<br>参数：callback[, initialValue]<br>参数说明：</p><p>callback迭代函数，有四个参数（prev, cur, index, array）</p><p>prev 前一个值，（initialValue || 数组第一项 || 上一次迭代的结果）<br>cur 当前迭代项<br>index 当前迭代项索引<br>array 迭代的原数组</p><p>initialValue 迭代的基础值，不传基础值是数组第一项</p><p>返回值：数组迭代后，整体的迭代结果<br>原数组是否改变：涉及callback，因此不确定，具体详情见下文中的原型方法的小结部分。<br>// 数组求和<br>let arr = [1, 2, 3];<br>let sum = arr.reduce((prev, cur, index, array) =&gt; {<br>    return prev + cur;<br>});<br>console.log(arr, sum); // [ 1, 2, 3 ] 6</p><p>// 传initialValue 基础值的示例<br>let sum1 = arr.reduce((prev, cur, index, array) =&gt; {<br>    return prev + cur;<br>}, 10);<br>// 返回的值是：10+1+2+3<br>console.log(arr, sum1); // [ 1, 2, 3 ] 16<br>复制代码<br>reduce源码的实现：<br>Array.prototype.myReduce = function(callback, initialVal){<br>   let prev = initialVal || this[0];<br>    for(var i = pre ? 0 : 1; i &lt; this.length; i++){<br>        prev = callback(prev, this[i], i, this);<br>   }<br>   return prev<br>}<br>复制代码</p><p><strong>19.reduceRight():</strong><br>作用：从数组的最后一项开始，逐步遍历到第一项，迭代数组的所有项（ES5方法）<br>参数：callback[, initialValue]<br>参数说明：</p><p>callback迭代函数，有四个参数（prev, cur, index, array）</p><p>prev 前一个值，（initialValue || 数组第一项 || 上一次迭代的结果）<br>cur 当前迭代项<br>index 当前迭代项索引<br>array 迭代的原数组</p><p>initialValue 迭代的基础值，不传基础值是数组第一项</p><p>返回值：数组迭代后，整体的迭代结果<br>原数组是否改变：涉及callback，因此不确定，具体详情见下文中的原型方法的小结部分。<br>// 拼接字符串,从后向前迭代数组进行拼接<br>let arr = [‘h’, ‘e’, ‘l’, ‘l’, ‘o’];<br>let str = arr.reduceRight((prev, cur, index, array) =&gt; {<br>    return prev + cur;<br>});<br>console.log(arr, str); // [ ‘h’, ‘e’, ‘l’, ‘l’, ‘o’ ] ‘olleh’<br>复制代码</p><p><strong>20.find():</strong><br>作用：查找数组中第一个符合条件的元素，返回该元素 (ES6新增)<br>参数：callback[, thisArg]<br>参数说明：参数的使用同上述的forEach、every、map、some、filter方法一致<br>返回值：查找到则返回该元素，没找到返回undefined<br>原数组是否改变：涉及callback，因此不确定，具体详情见下文中的原型方法的小结部分。<br>let arr = [1, 2, 3, 4, 5];<br>let temp = arr.find((item, index, array) =&gt; {<br>    return item &gt; 2;<br>})<br>console.log(arr, temp); // [1, 2, 3, 4, 5] 3<br>复制代码</p><p><strong>21.findIndex():</strong><br>作用：查找数组中第一个符合条件的元素所在位置的索引，并返回该索引值<br>参数：callback[, thisArg]<br>参数说明：参数的使用同上述的forEach、every、map、some、filter方法一致<br>返回值：查找到则返回该索引值，没找到返回-1<br>原数组是否改变：涉及callback，因此不确定，具体详情见下文中的原型方法的小结部分。<br>let arr = [1, 2, 3, 4, 5];<br>let temp = arr.findIndex((item, index, array) =&gt; {<br>    return item &gt; 2;<br>})<br>console.log(arr, temp); // [1, 2, 3, 4, 5] 2<br>复制代码</p><p><strong>22.fill():</strong><br>作用：用指定元素，填充数组从start(包括)到end（不包括）之间的元素，如果该区间内已经有元素，直接替换掉（ES6新增）<br>参数：value[, start[, end]]<br>返回值：填充后的数组<br>原数组是否改变：是<br>let arr = [1, 2, 3, 4, 5];<br>let temp = arr.fill(‘a’, 2, 4);<br>console.log(arr, temp); // [1, 2, ‘a’, ‘a’, 5] [1, 2, ‘a’, ‘a’, 5]<br>复制代码</p><p><strong>23.includes():</strong><br>作用：判断数组中是否包含指定的元素（ES7新增）<br>参数：searchElement[, fromIndex]<br>返回值：true或false<br>原数组是否改变：否<br>let arr = [1, 2, 3, 4, 5];<br>let temp = arr.includes(5);<br>console.log(arr, temp); // [1, 2, 3, 4, 5] true</p><p>// 这个方法弥补了indexOf查看元素时的一个不足，即查找NaN的误差<br>let arr1 = [NaN, ‘a’];<br>let temp1 = arr1.includes(NaN);<br>let temp2 = arr1.indexOf(NaN);<br>console.log(temp1, temp2); // true -1<br>复制代码</p><p><strong>24.toString()、toLocalString():</strong><br>作用：调用数组每一项的toString()方法，返回的是以逗号分隔的字符串<br>参数：无<br>返回值：转化后的字符串<br>原字数组是否改变：否<br>let arr = [1, [1, 2, [4]], {name: “zhangsan”}, 3];<br>let temp = arr.toString();<br>console.log(arr); [ 1, [ 1, 2, [ 4 ] ], { name: ‘zhangsan’ }, 3 ]<br>console.log(temp); // ‘1,1,2,4,[object Object],3’<br>复制代码</p><p><strong>25.join():</strong><br>作用：将数组元素转化为字符串(调用每个元素的toString方法)，并使用指定的分隔符（默认为逗号）进行拼接，返回拼接后的字符串<br>参数：分隔符，默认为逗号（，）<br>返回值：拼接后的字符串<br>原数组是否改变：否<br>let arr = [1, [1, 2, [4]], {name: “zhangsan”}, 3];<br>let temp = arr.join();<br>console.log(arr); [ 1, [ 1, 2, [ 4 ] ], { name: ‘zhangsan’ }, 3 ]<br>console.log(temp); // ‘1,1,2,4,[object Object],3’</p><p>// 数组求和<br>let arr1 = [1, 2, 3];<br>console.log(eval(arr1.join(‘+’))); // 6</p><p><strong>数组扩展运算符（ES6新增）</strong></p><p>数组的扩展运算符可以将数组转化为以逗号分割的参数序列。<br>几个简单使用的应用场景：</p><p>1.将数组通过扩展运算符转化为参数序列直接传参，无需使用apply转化了let arr = [1, 2, 3];</p><p>// apply写法<br>Math.min.apply(null, arr)</p><p>// 扩展运算符写法<br>Math.min(…arr)<br>复制代码<br>2.可以用于复制和拼接数组let arr1 = [2, 3, 4];<br>let arr2 = [‘a’, ‘b’, ‘c’];</p><p>// 拼接数组arr1和arr2<br>console.log([…arr1, …arr2]); // [2, 3, 4, ‘a’, ‘b’, ‘c’]<br>复制代码<br>3.可用于将字符串分解为真正的数组，[…’hello’]  // [ ‘h’, ‘e’, ‘l’, ‘l’, ‘o’ ]</p>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js常用方法</title>
      <link href="/2019/01/22/js-chang-yong-fang-fa/"/>
      <url>/2019/01/22/js-chang-yong-fang-fa/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><hr><p>你真的了解JS的那些方法吗？</p>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GIS基本使用</title>
      <link href="/2018/04/22/gis-ji-ben-shi-yong/"/>
      <url>/2018/04/22/gis-ji-ben-shi-yong/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=411214279&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="从0搭建自己的webpack开发环境"><a href="#从0搭建自己的webpack开发环境" class="headerlink" title="从0搭建自己的webpack开发环境"></a>从0搭建自己的webpack开发环境</h1><hr><p><strong>1.什么是Webpack?</strong><br><strong>webpack</strong>是一个现代 <strong>JavaScript</strong> 应用程序的<strong>静态模块打包器</strong>(module bundler)，当 webpack 处理应用程序时，它会递归地构建一个<strong>依赖关系图</strong>(dependency graph)，其中包含应用程序需要的每个<strong>模块</strong>，然后将所有这些模块打包成一个或多个 <strong>bundle</strong><br><img src="node.jpg" alt></p><p>使用Webpack作为前端构建工具：</p><p>· 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等；<br>· 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等；<br>· 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载；<br>· 模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件；<br>· 自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器；<br>· 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过；<br>· 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</p><p>在<strong>webpack</strong>应用中有两个核心:</p><p>模块转换器，用于把模块原内容按照需求转换成新内容，可以加载非 JS 模块；</p><p>扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。</p><p><strong>2.初始化项目</strong></p>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一名【合格】前端工程师的自检清单</title>
      <link href="/2018/01/22/self-checking/"/>
      <url>/2018/01/22/self-checking/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><hr><p>前端开发是一个非常特殊的行业，它的历史实际上不是很长，但是知识之繁杂，技术迭代速度之快是其他技术所不能比拟的。</p><p><strong>winter</strong>在他的《重学前端》课程中提到：</p><!-- ![](749826.jpg) --><!-- 最后引用《我的少女时代》里的一句话吧。 --><blockquote><p>到现在为止，前端工程师已经成为研发体系中的重要岗位之一。可是，与此相对的是，我发现极少或者几乎没有大学的计算机专业愿意开设前端课程，更没有系统性的教学方案出现。大部分前端工程师的知识，其实都是来自于实践和工作中零散的学习。</p></blockquote><p>这样是一个非常真实的现状，实际上很多前端开发者都是自学甚至转行过来的，前端入门简单，学习了几个API以后上手做项目也很简单，但是这往往成为了限制自身发展的瓶颈。<br>只是停留在会用阶段是远远不够的，我们还需要不断探索和深入。现在市面上并不缺少学习教程，技术文章，如果盲目的学习你会发现看过以后的知识留存率会很低，而且发现没有了解到的知识越来越多，这会让人产生焦虑。<br>实际上，除了坚持学习的强大的自驱力，你还需要一个很简单的学习方法。那就是：建立自己的知识体系。它能帮助你更系统性的学习，同时你也时刻能知道自己哪些地方是不足的。<br>我会把我工作和学习中接触到的知识全部归纳到我的知识体系中，其中不仅仅包括我已经学过的，还有很多我没有来得及学习的。</p><p>下面我会把我的自检清单分享给大家，你可以按照清单上的知识检测自己还有哪些不足和提升，我也建议大家建自己的知识体系，这样工作或者学习甚至面试时，你能快速定位到知识清单中的点，如果你有哪些我没归纳到的点，欢迎在评论区告诉我。</p><p><img src="01.jpg" alt> </p><h1 id="一、JavaScript基础"><a href="#一、JavaScript基础" class="headerlink" title="一、JavaScript基础"></a>一、JavaScript基础</h1><blockquote><p>前端工程师吃饭的家伙，深度、广度一样都不能差。</p></blockquote><p><strong>变量和类型</strong><br>· 1.JavaScript规定了几种语言类型</p><p>· 2.JavaScript对象的底层数据结构是什么</p><p>· 3.Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol</p><p>· 4.JavaScript中的变量在内存中的具体存储形式</p><p>· 5.基本类型对应的内置对象，以及他们之间的装箱拆箱操作</p><p>· 6.理解值类型和引用类型</p><p>· 7.null和undefined的区别</p><p>. 8至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提高工作效率的常用js函数汇总</title>
      <link href="/2018/01/22/ti-gao-gong-zuo-xiao-lu-de-chang-yong-js-han-shu-hui-zong/"/>
      <url>/2018/01/22/ti-gao-gong-zuo-xiao-lu-de-chang-yong-js-han-shu-hui-zong/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文总结了项目开发过程中常用的js函数和正则，意在提高大家平时的开发效率，具体内容如下：</p><ol><li>常用的正则校验</li><li>常用的设备检测方式</li><li>常用的日期时间函数</li><li>跨端事件处理</li><li>js移动端适配方案</li><li>xss预防方式</li><li>常用的js算法(防抖，截流，去重，排序，模板渲染，观察者…)</li><li>……</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="1-正则"><a href="#1-正则" class="headerlink" title="1. 正则"></a>1. 正则</h3><pre><code>  // 匹配邮箱  let reg = /^([a-zA-Z]|[0-9])(\w|\-)+@[a-zA-Z0-9]+\.([a-zA-Z]{2,4})$  // (新)匹配手机号  let reg = /^1[0-9]{10}$/;  // (旧)匹配手机号  let reg = /^1(3|4|5|7|8)[0-9]{9}$/;  // 匹配8-16位数字和字母密码的正则表达式  let reg = /^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{8,16}$/;  // 匹配国内电话号码 0510-4305211  let reg = /\d{3}-\d{8}|\d{4}-\d{7}/;  // 匹配身份证号码  let reg=/(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/;  // 匹配腾讯QQ号  let reg = /[1-9][0-9]{4,}/;  // 匹配ip地址  let reg = /\d+\.\d+\.\d+\.\d+/;  // 匹配中文  let reg = /^[\u4e00-\u9fa5]*$/;</code></pre><h3 id="2-检测平台（设备）类型"><a href="#2-检测平台（设备）类型" class="headerlink" title="2.检测平台（设备）类型"></a>2.检测平台（设备）类型</h3><pre><code>  let isWechat = /micromessenger/i.test(navigator.userAgent),  isWeibo = /weibo/i.test(navigator.userAgent),  isQQ = /qq\//i.test(navigator.userAgent),  isIOS = /(iphone|ipod|ipad|ios)/i.test(navigator.userAgent),  isAndroid = /android/i.test(navigator.userAgent);</code></pre><h3 id="3-常用的日期时间函数"><a href="#3-常用的日期时间函数" class="headerlink" title="3. 常用的日期时间函数"></a>3. 常用的日期时间函数</h3><pre><code>  // 时间格式化  function format_date(timeStamp) {      let date = new Date(timeStamp);      return date.getFullYear() + &quot;年&quot;          + prefix_zero(date.getMonth() + 1) + &quot;月&quot;          + prefix_zero(date.getDate()) + &quot;日 &quot;          + prefix_zero(date.getHours()) + &quot;:&quot;          + prefix_zero(date.getMinutes());  }  // moment.js方法  //require 方式  var moment=require(&#39;moment&#39;);  //import 方式  import moment from &#39;moment&#39;;  格式化时间类型  1.取当天时间，以YYYY年MM月DD日形式显示  var now=moment().format(&quot;YYYY年MM月DD日&quot;);  2.任意时间戳格式化，以YYYY-MM-DD HH:mm:ss形式显示  var t1=moment(1411641720000).format(&#39;YYYY-MM-DD HH:mm:ss&#39;);  获取前一天日期，格式以YYYY-MM-DD形式显示  var t11=moment().day(0).format(&#39;YYYY-MM-DD&#39;);  获取本周五日期，格式以YYYY-MM-DD形式显示  var t12=moment().weekday(5).format(&#39;YYYY-MM-DD&#39;);  获取上周五日期，格式以YYYY-MM-DD形式显示  var t13=moment().weekday(-3).format(&#39;YYYY-MM-DD&#39;);  可以简单理解为上周倒数第几天，上周倒数第三天就是上周五了，和当天日期无关  获取当前年份、月份、日期  var t14=moment().year()  var t15=moment().month()//此处月份从0开始，当前月要+1  var t16=moment().date();  // 数字格式化  function prefix_zero(num) {      return num &gt;= 10 ? num : &quot;0&quot; + num;  }  // 倒计时时间格式化  function format_time(timeStamp) {      let day = Math.floor(timeStamp / (24 * 3600 * 1000));      let leave1 = timeStamp % (24 * 3600 * 1000);      let hours = Math.floor(leave1 / (3600 * 1000));      let leave2 = leave1 % (3600 * 1000);      let minutes = Math.floor(leave2 / (60 * 1000));      let leave3 = leave2 % (60 * 1000);      let seconds = Math.floor(leave3 / 1000);      if (day) return day + &quot;天&quot; + hours + &quot;小时&quot; + minutes + &quot;分&quot;;      if (hours) return hours + &quot;小时&quot; + minutes + &quot;分&quot; + seconds + &quot;秒&quot;;      if (minutes) return minutes + &quot;分&quot; + seconds + &quot;秒&quot;;      if (seconds) return seconds + &quot;秒&quot;;      return &quot;时间到！&quot;;  }</code></pre><h3 id="4-跨端事件处理"><a href="#4-跨端事件处理" class="headerlink" title="4.跨端事件处理"></a>4.跨端事件处理</h3><pre><code>  // 是否支持触摸事件  let isSupportTouch = (&quot;ontouchstart&quot; in document.documentElement) ? true : false;  //禁用Enter键表单自动提交  document.onkeydown = function(event) {      let target, code, tag;      if (!event) {          event = window.event; //针对ie浏览器          target = event.srcElement;          code = event.keyCode;          if (code == 13) {              tag = target.tagName;              if (tag == &quot;TEXTAREA&quot;) { return true; }              else { return false; }          }      }      else {          target = event.target; //针对遵循w3c标准的浏览器，如Firefox          code = event.keyCode;          if (code == 13) {              tag = target.tagName;              if (tag == &quot;INPUT&quot;) { return false; }              else { return true; }          }      }  };</code></pre><h3 id="5-移动端适配方案"><a href="#5-移动端适配方案" class="headerlink" title="5. 移动端适配方案"></a>5. 移动端适配方案</h3><pre><code>  (function (doc, win) {      var docEl = doc.documentElement,          resizeEvt = &#39;orientationchange&#39; in window ? &#39;orientationchange&#39; : &#39;resize&#39;,          recalc = function () {              var clientWidth = docEl.clientWidth;              var fontSize = 20;              docEl.style.fontSize = fontSize + &#39;px&#39;;              var docStyles = getComputedStyle(docEl);              var realFontSize = parseFloat(docStyles.fontSize);              var scale = realFontSize / fontSize;              console.log(&quot;realFontSize: &quot; + realFontSize + &quot;, scale: &quot; + scale);              fontSize = clientWidth / 667 * 20;              if(isIphoneX()) fontSize = 19;              fontSize = fontSize / scale;              docEl.style.fontSize = fontSize + &#39;px&#39;;          };      // Abort if browser does not support addEventListener      if (!doc.addEventListener) return;      win.addEventListener(resizeEvt, recalc, false);      doc.addEventListener(&#39;DOMContentLoaded&#39;, recalc, false);      // iphoneX判断      function isIphoneX(){          return /iphone/gi.test(navigator.userAgent) &amp;&amp; (screen.height == 812 &amp;&amp; screen.width == 375)      }  })(document, window);</code></pre><h3 id="6-xss预防方式"><a href="#6-xss预防方式" class="headerlink" title="6.xss预防方式"></a>6.xss预防方式</h3><pre><code>  // 敏感符号转义  function entities(s) {      let e = {          &#39;&quot;&#39;: &#39;&amp;quot;&#39;,          &#39;&amp;&#39;: &#39;&amp;amp;&#39;,          &#39;&lt;&#39;: &#39;&amp;lt;&#39;,          &#39;&gt;&#39;: &#39;&amp;gt;&#39;      }      return s.replace(/[&quot;&lt;&gt;&amp;]/g, m =&gt; {          return e[m]      })  }</code></pre><h3 id="7-JS方法"><a href="#7-JS方法" class="headerlink" title="7. JS方法"></a>7. JS方法</h3><pre><code>  // 数组去重方法   1. 过滤+indexof  function distinct(arr = testArr) {      return arr.filter((v, i, array) =&gt; array.indexOf(v) === i)  }  2. 双重for循环  var array = [1, 1, &#39;1&#39;, &#39;1&#39;];  function unique(array) {      // res用来存储结果      var res = [];      for (var i = 0, arrayLen = array.length; i &lt; arrayLen; i++) {          for (var j = 0, resLen = res.length; j &lt; resLen; j++ ) {              if (array[i] === res[j]) {                  break;              }          }          // 如果array[i]是唯一的，那么执行完循环，j等于resLen          if (j === resLen) {              res.push(array[i])          }      }      return res;  }  console.log(unique(array)); // [1, &quot;1&quot;]  3.排序后相邻去除法   var array = [1, 1, &#39;1&#39;];  function unique(array) {      var res = [];      var sortedArray = array.concat().sort();      var seen;      for (var i = 0, len = sortedArray.length; i &lt; len; i++) {          // 如果是第一个元素或者相邻的元素不相同          if (!i || seen !== sortedArray[i]) {              res.push(sortedArray[i])          }          seen = sortedArray[i];      }      return res;  }  console.log(unique(array));  4.Object 键值对  var array = [1, 2, 1, 1, &#39;1&#39;];  function unique(array) {      var obj = {};      return array.filter(function(item, index, array){          return obj.hasOwnProperty(item) ? false : (obj[item] = true)      })  }  console.log(unique(array)); // [1, 2]  //-----------------------------------------  var array = [{value: 1}, {value: 1}, {value: 2}];  function unique(array) {      var obj = {};      return array.filter(function(item, index, array){          console.log(typeof item + JSON.stringify(item))          return obj.hasOwnProperty(typeof item + JSON.stringify(item)) ? false : (obj[typeof item + JSON.stringify(item)] = true)      })  }  console.log(unique(array)); // [{value: 1}, {value: 2}]  5.ES6  var array = [1, 2, 1, 1, &#39;1&#39;];  function unique(array) {    return Array.from(new Set(array));  }  console.log(unique(array)); // [1, 2, &quot;1&quot;]  // 置换函数  function swap(arr, indexA, indexB) {      [arr[indexA], arr[indexB]] = [arr[indexB], arr[indexA]];  }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
